class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        
        // Reposition slingshot to left side of screen
        this.SLINGSHOT_X = 300; // Keep at 300 (positioned on left side)
        this.SLINGSHOT_Y = 800; // Keep at same height
        this.MAX_DRAG_DISTANCE = 200;
        this.SHOT_POWER = 0.13; // Increased shot power (from 0.07)
        this.MAX_SHOTS = 10;
        this.shotsRemaining = this.MAX_SHOTS;
        this.isAiming = false;
        this.revealPercentage = 0;
        this.targetPercentage = 85;
        this.UI_DEPTH = 1000; // UI depth for consistent layering
        this.isLevelComplete = false;
        this.isGameOver = false;
        
        // Reference to block manager
        this.blockManager = null;
        
        // Add bomb state tracking to prevent stuck game state
        this.bombState = {
            active: false,
            lastResetTime: 0,
            lastBombFired: 0,
            pendingReset: null,
            maxIdleTime: 20000, // Auto-reset if bomb is idle for 20 seconds
            autoResetTimer: null
        };
        
        // Add developer method to refresh UI
        if (window) {
            window.refreshGameUI = () => {
                console.log('Forcing UI refresh...');
                if (this.bombSelectorContainer) {
                    this.bombSelectorContainer.destroy();
                    this.bombSelectorContainer = null;
                }
                this.createBombSelector();
                console.log('UI refreshed!');
                return 'UI refreshed successfully!';
            };
        }
        
        // Audio properties
        this.bgMusic = null;
        this.victoryMusic = null;
        
        // Bomb types with names from Game Design Document
        this.BOMB_TYPES = {
            BLAST: 'blast_bomb',
            PIERCER: 'piercer_bomb',
            CLUSTER: 'cluster_bomb',
            STICKY: 'sticky_bomb',
            SHATTERER: 'shatterer_bomb',
            DRILLER: 'driller_bomb'  // Add Driller Girl bomb type
        };
        
        // Bomb names based on Game Design Document
        this.BOMB_NAMES = {
            [this.BOMB_TYPES.BLAST]: 'Blast Girl',
            [this.BOMB_TYPES.PIERCER]: 'Piercer Girl',
            [this.BOMB_TYPES.CLUSTER]: 'Cluster Girl',
            [this.BOMB_TYPES.STICKY]: 'Sticky Girl',
            [this.BOMB_TYPES.SHATTERER]: 'Shatterer Girl',
            [this.BOMB_TYPES.DRILLER]: 'Driller Girl'  // Add Driller Girl name
        };
        
        // Remaining bombs of each type
        this.bombsRemaining = {
            [this.BOMB_TYPES.BLAST]: 3,
            [this.BOMB_TYPES.PIERCER]: 5,
            [this.BOMB_TYPES.CLUSTER]: 1,
            [this.BOMB_TYPES.STICKY]: 5,
            [this.BOMB_TYPES.SHATTERER]: 1,
            [this.BOMB_TYPES.DRILLER]: 3  // Add initial count for Driller Girl bombs
        };
        
        // Current selected bomb type
        this.currentBombType = this.BOMB_TYPES.BLAST;
        
        // Debug mode for testing
        this.debugMode = true;
        
        // Configure the game for better performance with frequent pixel operations
        this.willReadPixelsFrequently = true;
    }

    create() {
        try {
            // Clear any cached textures or game objects to ensure fresh UI
            this.game.textures.list = this.textures.list;
            
            // Setup camera to show the full 1920x1080 game world
            this.setupCamera();
            
            // Set zero gravity (world bounds are set in setupCamera)
            this.matter.world.setGravity(0, 0); // Zero gravity for space-like environment

            // Initialize arrays for game objects
            this.activeStickyBombs = [];
            
            // Create trajectoryPoints for aiming path
            this.trajectoryPoints = [];
            this.trajectoryGraphics = this.add.graphics();
            this.trajectoryGraphics.setDepth(15); // Higher depth than blocks (4) to ensure visibility
            
            // Create game objects
            this.createBackground();
            
            // Initialize the block manager
            this.initializeBlockManager();
            
            // Create the completion veil based on chibi image shape
            this.createCompletionVeil();
            
            // Create slingshot
            this.createSlingshot();
            this.createTargets();
            
            // Create UI before resetting bomb
            this.createUI();
            
            // Reset bomb and prepare for first shot
            this.resetBomb();
            
            // Setup input handlers
            this.setupInputHandlers();
            
            // Directly initialize audio (simpler approach)
            this.initializeAudio();
            
            // Create bouncy blocks boundary - removed
            // this.createBoundaryBouncyBlocks();
            
            // Setup global failsafe timer to detect stuck game states
            this.setupGlobalFailsafe();
            
            // Debug text display - moved to bottom of screen
            if (this.debugMode) {
                this.debugText = this.add.text(10, this.cameras.main.height - 30, 'Debug: Ready', { 
                    font: '16px Arial', 
                    fill: '#ffffff',
                    backgroundColor: '#333333',
                    padding: { x: 5, y: 2 }
                });
                this.debugText.setDepth(this.UI_DEPTH - 1); // Below UI but above game elements
            }
            
            // Make sure UIScene is running - in case it wasn't started or was stopped
            if (!this.scene.isActive('UIScene')) {
                console.log("Starting UIScene from GameScene");
                this.scene.launch('UIScene');
            }
            
            // Send initial events to update UI
            this.events.emit('updateShots', this.shotsRemaining);
            this.events.emit('updatePercentage', this.revealPercentage);
            
            console.log("GameScene created successfully");
        } catch (error) {
            console.error("Error in create:", error);
        }
    }
    
    // Initialize the BlockManager
    initializeBlockManager() {
        console.log("Initializing BlockManager...");
        try {
            // Create a new BlockManager instance
            this.blockManager = new BlockManager(this);
            
            // Create a reference to the block types
            this.BLOCK_TYPES = this.blockManager.BLOCK_TYPES;
            
            console.log("BlockManager initialized successfully with block types:", this.BLOCK_TYPES);
            return true;
        } catch (error) {
            console.error("Error initializing BlockManager:", error);
            
            // If BlockManager fails to initialize, set up fallback block types
            this.BLOCK_TYPES = {
                STANDARD: 'standard',
                STRONG: 'strong',
                DYNAMITE: 'dynamite',
                ETERNAL: 'eternal',
                BOUNCY: 'bouncy'
            };
            
            console.log("Using fallback block types due to BlockManager initialization failure");
            return false;
        }
    }

    setupCamera() {
        // Set up the main camera to show the entire 1920x1080 game area without overflow
        const gameWidth = 1920;
        const gameHeight = 1080;
        
        // Set strict bounds for the main camera
        this.cameras.main.setBounds(0, 0, gameWidth, gameHeight);
        this.cameras.main.setBackgroundColor('#000000');
        this.cameras.main.setViewport(0, 0, gameWidth, gameHeight);
        
        // Make sure the camera is properly scaled according to the game config
        const scaleX = this.scale.width / gameWidth;
        const scaleY = this.scale.height / gameHeight;
        
        console.log(`Camera setup: Game dimensions ${this.scale.width}x${this.scale.height}, Scale: ${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`);
        
        // Create a UI camera specifically for UI elements with highest depth
        this.uiCamera = this.cameras.add(0, 0, gameWidth, gameHeight);
        this.uiCamera.setName('UI Camera');
        this.uiCamera.setScroll(0, 0);
        this.uiCamera.setBackgroundColor(0x000000, 0); // Transparent background
        
        // Only include UI elements in this camera (depth >= UI_DEPTH)
        this.uiCamera.ignore(this.children.list.filter(item => item.depth < this.UI_DEPTH));
        
        // Ensure our world physics is larger than our camera bounds to prevent bombs from hitting invisible walls
        // Extend the physics world by 2000 pixels in each direction
        this.matter.world.setBounds(-2000, -2000, gameWidth + 4000, gameHeight + 4000);
        
        // Debug camera bounds if in debug mode
        if (this.debugMode) {
            console.log(`Main camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`UI camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`Physics world bounds: -2000, -2000, ${gameWidth + 4000}, ${gameHeight + 4000}`);
            console.log(`UI depth: ${this.UI_DEPTH}`);
        }
    }

    createBackground() {
        try {
            // Create a container with specific depth for layering
            this.backgroundContainer = this.add.container(0, 0);
            this.backgroundContainer.setDepth(0); // Lowest depth for background
            
            // Check if level background was loaded successfully
            let bgImage;
            if (this.textures.exists('levelBackground')) {
                // Use the loaded background image
                bgImage = this.add.image(1920/2, 1080/2, 'levelBackground');
                console.log("Using loaded level background image");
            } else {
                // Fallback to default background
                bgImage = this.add.image(1920/2, 1080/2, 'background');
                console.log("Fallback to default background");
            }
            
            // Set background to lowest depth to ensure it's behind everything
            bgImage.setDepth(0);
            
            // Position the chibi image on the right side of the screen
            // Use 2/3 of the screen width for X position to move it rightward
            const chibiX = Math.floor(1920 * 0.7); // 70% of screen width
            const chibiY = 1080/2; // Centered vertically
            
            // Add the chibi image - explicitly use chibi_girl1 as the key
            console.log("Loading chibi image with key: 'chibi_girl1'");
            this.chibiImage = this.add.image(chibiX, chibiY, 'chibi_girl1');
            this.chibiImage.setDepth(1); // Depth 1 for chibi image - blocks should be higher
            
            // Debug the loaded image
            console.log("Chibi image texture:", this.chibiImage.texture.key);
            console.log("Chibi image frame:", this.chibiImage.frame?.name || "default");
            
            // Use the image at its original size without any scaling
            this.chibiImage.setScale(1.0);
            
            // Set the image to be fully opaque
            this.chibiImage.setAlpha(1);
            
            // Store dimensions for later reference
            const chibiWidth = this.chibiImage.width;
            const chibiHeight = this.chibiImage.height;
            
            // Log the new position
            console.log("Background created with chibi image positioned at:", 
                        chibiX, chibiY,
                        "with dimensions:", chibiWidth, "x", chibiHeight);
        } catch (error) {
            console.error("Error in createBackground:", error);
        }
    }

    createIceBlocks() {
        this.iceBlocks = [];
        this.blueVeils = []; // Array to store individual blue veil rectangles
        const blockSize = 15; // Reduced to 1/4 of original size (was 60)
        
        // Create a container for ice blocks with depth above chibi but below UI
        const blocksContainer = this.add.container(0, 0);
        blocksContainer.setDepth(2);
        
        // Get the chibi image bounds with scaling applied
        const scale = this.chibiImage.scale; // Get actual scale being used
        const imageWidth = this.chibiImage.width; 
        const imageHeight = this.chibiImage.height;
        
        // Calculate the image boundaries
        const imageX = this.chibiImage.x - (imageWidth * scale) / 2;
        const imageY = this.chibiImage.y - (imageHeight * scale) / 2;
        
        // Calculate grid dimensions
        const cols = Math.ceil(imageWidth * scale / blockSize);
        const rows = Math.ceil(imageHeight * scale / blockSize);
        
        console.log(`Chibi image at ${this.chibiImage.x}, ${this.chibiImage.y}, scale: ${scale}`);
        console.log(`Image calculated bounds: ${imageX}, ${imageY}, ${imageWidth * scale}x${imageHeight * scale}`);
        console.log(`Creating ice blocks grid: ${cols}x${rows} over image area ${imageWidth * scale}x${imageHeight * scale}`);
        
        // Create a temporary canvas to check pixel data
        const tempCanvas = document.createElement('canvas');
        const tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = imageWidth;
        tempCanvas.height = imageHeight;
        
        // Get the texture key of the chibi image
        const textureKey = this.chibiImage.texture.key;
        
        // Get the image data
        const frame = this.textures.getFrame(textureKey);
        const source = frame.source.image || frame.source.canvas;
        
        // Draw the image to our temp canvas
        tempContext.drawImage(source, 0, 0, imageWidth, imageHeight);
        
        // Alpha threshold - lower value to include more semi-transparent pixels at edges
        const alphaThreshold = 50; // Much lower threshold to catch edge pixels
        
        // Sample size for checking multiple pixels in the block area
        const sampleSize = 5; // Check more points in a 5x5 grid
        const sampleOffset = Math.floor(blockSize / (sampleSize + 1) / scale);
        
        // Create a 2D grid to track where we've placed blocks
        const blockGrid = Array(rows).fill().map(() => Array(cols).fill(false));
        
        // Variables to track total blocks for percentage calculations
        this.totalIceBlocks = 0;
        this.clearedIceBlocks = 0;
        
        // First pass: Find all core pixels that meet the alpha threshold
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Sample multiple points within this block area
                let hasVisiblePixel = false;
                
                for (let sx = 0; sx < sampleSize; sx++) {
                    for (let sy = 0; sy < sampleSize; sy++) {
                        // Calculate sampling position in the original image
                        const offsetX = -Math.floor(sampleSize/2) + sx;
                        const offsetY = -Math.floor(sampleSize/2) + sy;
                        
                        const sampleX = Math.floor(col * blockSize / scale) + offsetX * sampleOffset;
                        const sampleY = Math.floor(row * blockSize / scale) + offsetY * sampleOffset;
                        
                        // Ensure we're within bounds
                        if (sampleX >= 0 && sampleX < imageWidth && 
                            sampleY >= 0 && sampleY < imageHeight) {
                            
                            try {
                                const pixelData = tempContext.getImageData(sampleX, sampleY, 1, 1).data;
                                // If any sampled pixel has alpha above threshold, mark block as visible
                                if (pixelData[3] >= alphaThreshold) {
                                    hasVisiblePixel = true;
                                    break;
                                }
                            } catch (e) {
                                console.error(`Error sampling pixel at ${sampleX},${sampleY}:`, e);
                            }
                        }
                    }
                    if (hasVisiblePixel) break;
                }
                
                if (hasVisiblePixel) {
                    blockGrid[row][col] = true;
                }
            }
        }
        
        // Second pass: Add padding around detected pixels to ensure edges are covered
        // This creates a thickness around the chibi image
        const paddingAmount = 1; // How many blocks of padding to add
        
        // Create a copy of the grid before adding padding
        const originalGrid = blockGrid.map(row => [...row]);
        
        // Add padding around each detected block
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (originalGrid[row][col]) {
                    // Add padding blocks around this block
                    for (let pr = -paddingAmount; pr <= paddingAmount; pr++) {
                        for (let pc = -paddingAmount; pc <= paddingAmount; pc++) {
                            const padRow = row + pr;
                            const padCol = col + pc;
                            
                            // Make sure we're in bounds
                            if (padRow >= 0 && padRow < rows && padCol >= 0 && padCol < cols) {
                                blockGrid[padRow][padCol] = true;
                            }
                        }
                    }
                }
            }
        }
        
        // Prepare to create exactly 3 dynamite blocks
        const dynamitePositions = [];
        const validPositions = [];
        
        // Collect all valid block positions first
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (blockGrid[row][col]) {
                    const blockScreenX = imageX + col * blockSize + blockSize / 2;
                    const blockScreenY = imageY + row * blockSize + blockSize / 2;
                    validPositions.push({x: blockScreenX, y: blockScreenY, row, col});
                }
            }
        }
        
        // Pick 3 random positions for dynamite blocks (if we have enough blocks)
        if (validPositions.length > 3) {
            // Shuffle the array to get random positions
            for (let i = validPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
            }
            
            // Take the first 3 positions for dynamite
            for (let i = 0; i < 3; i++) {
                dynamitePositions.push({
                    x: validPositions[i].x,
                    y: validPositions[i].y,
                    row: validPositions[i].row,
                    col: validPositions[i].col
                });
            }
        }
        
        // Third pass: Create blocks based on our grid
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (!blockGrid[row][col]) continue;
                
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Determine block type
                let blockType = 'standard'; // Default is standard
                
                // Check if this position is one of our dynamite positions
                const isDynamite = dynamitePositions.some(pos => 
                    pos.row === row && pos.col === col);
                
                if (isDynamite) {
                    blockType = 'dynamite';
                } else {
                    // For non-dynamite blocks, use weighted random for other special types
                    let blockTypeRand = Math.random();
                    if (blockTypeRand < 0.02) {
                        blockType = 'eternal';
                    } else if (blockTypeRand < 0.08) {
                        blockType = 'strong';
                    }
                }
                
                // Base physics properties
                let physicsProps = {
                    isStatic: true,
                    friction: 0.01, 
                    restitution: 0.3
                };
                
                // Adjust properties based on block type
                if (blockType === 'bouncy') {
                    physicsProps.restitution = 1.0; // Bouncy blocks have high restitution
                }
                
                // Create ice block
                const block = this.matter.add.image(blockScreenX, blockScreenY, 'iceBlock', null, physicsProps);
                
                // Scale the blocks to match the new size
                block.setScale(blockSize / 40); // Original ice block is 40x40, scale up
                
                // Set a slight random rotation for some blocks
                if (Math.random() < 0.3) {
                    block.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set blocks to appear above the chibi image with high depth
                block.setDepth(16); // Very high depth (higher than blue veils at 15)
                
                // Initialize block properties based on type
                block.isActive = true;
                block.blockType = blockType;
                
                // Set specific properties based on block type
                let veilColor, veilAlpha;
                
                switch(blockType) {
                    case 'eternal':
                        block.hitsLeft = 3;
                        veilColor = 0x3333cc; // Dark blue
                        veilAlpha = 0.9;
                        break;
                    case 'strong':
                        block.hitsLeft = 2;
                        veilColor = 0x6666dd; // Medium blue
                        veilAlpha = 0.85;
                        break;
                    case 'dynamite':
                        block.hitsLeft = 1;
                        veilColor = 0xdd3333; // Red
                        veilAlpha = 0.85;
                        // Add a bit of pulsing to the dynamite block
                        this.tweens.add({
                            targets: block,
                            alpha: 0.7,
                            yoyo: true,
                            repeat: -1,
                            duration: 600
                        });
                        break;
                    case 'bouncy': 
                        // This case is still used by boundary bouncy blocks
                        block.hitsLeft = 1;
                        veilColor = 0x00cc44; // Green color
                        veilAlpha = 0.9;
                        // Add pulsating effect like the boundary bouncy blocks
                        this.tweens.add({
                            targets: block,
                            alpha: { from: 0.5, to: 0.8 },
                            yoyo: true,
                            repeat: -1,
                            duration: 1500,
                            ease: 'Sine.easeInOut'
                        });
                        break;
                    default: // standard
                        block.hitsLeft = 1;
                        veilColor = 0xaaddff; // Default light blue
                        veilAlpha = 0.85;
                }
                
                block.setAlpha(0.5);
                
                // Create a blue veil rectangle for this block with type-specific color
                const blueVeil = this.add.rectangle(
                    blockScreenX, 
                    blockScreenY, 
                    blockSize, 
                    blockSize, 
                    veilColor,
                    veilAlpha
                );
                
                // Add an ice-like texture effect with highlights
                blueVeil.setStrokeStyle(2, 0xffffff, 0.3); // Add a subtle white border
                
                // Add a slight random rotation for a more natural ice look
                if (Math.random() < 0.5) {
                    blueVeil.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set the blue veil to appear above the chibi image with high depth
                blueVeil.setDepth(15); // Ensure very high depth for blue veils to be visible
                
                // Store reference to its corresponding blue veil in the block
                block.blueVeil = blueVeil;
                
                this.iceBlocks.push(block);
                this.blueVeils.push(blueVeil);
                
                this.createIceTextureEffect(blueVeil);
                
                // Count each ice block for percentage calculations
                this.totalIceBlocks++;
            }
        }
        
        // Ensure chibi image remains fully opaque after adding blue veils
        this.chibiImage.setAlpha(1);
        
        // Reset revealed pixels counter based on total ice blocks
        this.revealedPixels = 0;
        this.revealPercentage = 0;
        
        console.log(`Created ${this.iceBlocks.length} ice blocks with blue veils`);
        // Log the number of dynamite blocks created
        console.log(`Created exactly ${dynamitePositions.length} dynamite blocks`);
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        
        // Reposition slingshot to left side of screen
        this.SLINGSHOT_X = 300; // Keep at 300 (positioned on left side)
        this.SLINGSHOT_Y = 800; // Keep at same height
        this.MAX_DRAG_DISTANCE = 200;
        this.SHOT_POWER = 0.13; // Increased shot power (from 0.07)
        this.MAX_SHOTS = 10;
        this.shotsRemaining = this.MAX_SHOTS;
        this.isAiming = false;
        this.revealPercentage = 0;
        this.targetPercentage = 85;
        this.UI_DEPTH = 1000; // UI depth for consistent layering
        this.isLevelComplete = false;
        this.isGameOver = false;
        
        // Reference to block manager
        this.blockManager = null;
        
        // Add bomb state tracking to prevent stuck game state
        this.bombState = {
            active: false,
            lastResetTime: 0,
            lastBombFired: 0,
            pendingReset: null,
            maxIdleTime: 20000, // Auto-reset if bomb is idle for 20 seconds
            autoResetTimer: null
        };
        
        // Add developer method to refresh UI
        if (window) {
            window.refreshGameUI = () => {
                console.log('Forcing UI refresh...');
                if (this.bombSelectorContainer) {
                    this.bombSelectorContainer.destroy();
                    this.bombSelectorContainer = null;
                }
                this.createBombSelector();
                console.log('UI refreshed!');
                return 'UI refreshed successfully!';
            };
        }
        
        // Audio properties
        this.bgMusic = null;
        this.victoryMusic = null;
        
        // Bomb types with names from Game Design Document
        this.BOMB_TYPES = {
            BLAST: 'blast_bomb',
            PIERCER: 'piercer_bomb',
            CLUSTER: 'cluster_bomb',
            STICKY: 'sticky_bomb',
            SHATTERER: 'shatterer_bomb',
            DRILLER: 'driller_bomb'  // Add Driller Girl bomb type
        };
        
        // Bomb names based on Game Design Document
        this.BOMB_NAMES = {
            [this.BOMB_TYPES.BLAST]: 'Blast Girl',
            [this.BOMB_TYPES.PIERCER]: 'Piercer Girl',
            [this.BOMB_TYPES.CLUSTER]: 'Cluster Girl',
            [this.BOMB_TYPES.STICKY]: 'Sticky Girl',
            [this.BOMB_TYPES.SHATTERER]: 'Shatterer Girl',
            [this.BOMB_TYPES.DRILLER]: 'Driller Girl'  // Add Driller Girl name
        };
        
        // Remaining bombs of each type
        this.bombsRemaining = {
            [this.BOMB_TYPES.BLAST]: 3,
            [this.BOMB_TYPES.PIERCER]: 5,
            [this.BOMB_TYPES.CLUSTER]: 1,
            [this.BOMB_TYPES.STICKY]: 5,
            [this.BOMB_TYPES.SHATTERER]: 1,
            [this.BOMB_TYPES.DRILLER]: 3  // Add initial count for Driller Girl bombs
        };
        
        // Current selected bomb type
        this.currentBombType = this.BOMB_TYPES.BLAST;
        
        // Debug mode for testing
        this.debugMode = true;
        
        // Configure the game for better performance with frequent pixel operations
        this.willReadPixelsFrequently = true;
    }

    create() {
        try {
            // Clear any cached textures or game objects to ensure fresh UI
            this.game.textures.list = this.textures.list;
            
            // Setup camera to show the full 1920x1080 game world
            this.setupCamera();
            
            // Set zero gravity (world bounds are set in setupCamera)
            this.matter.world.setGravity(0, 0); // Zero gravity for space-like environment

            // Initialize arrays for game objects
            this.activeStickyBombs = [];
            
            // Create trajectoryPoints for aiming path
            this.trajectoryPoints = [];
            this.trajectoryGraphics = this.add.graphics();
            this.trajectoryGraphics.setDepth(15); // Higher depth than blocks (4) to ensure visibility
            
            // Create game objects
            this.createBackground();
            
            // Initialize the block manager
            this.initializeBlockManager();
            
            // Create the completion veil based on chibi image shape
            this.createCompletionVeil();
            
            // Create slingshot
            this.createSlingshot();
            this.createTargets();
            
            // Create UI before resetting bomb
            this.createUI();
            
            // Reset bomb and prepare for first shot
            this.resetBomb();
            
            // Setup input handlers
            this.setupInputHandlers();
            
            // Directly initialize audio (simpler approach)
            this.initializeAudio();
            
            // Create bouncy blocks boundary - removed
            // this.createBoundaryBouncyBlocks();
            
            // Setup global failsafe timer to detect stuck game states
            this.setupGlobalFailsafe();
            
            // Debug text display - moved to bottom of screen
            if (this.debugMode) {
                this.debugText = this.add.text(10, this.cameras.main.height - 30, 'Debug: Ready', { 
                    font: '16px Arial', 
                    fill: '#ffffff',
                    backgroundColor: '#333333',
                    padding: { x: 5, y: 2 }
                });
                this.debugText.setDepth(this.UI_DEPTH - 1); // Below UI but above game elements
            }
            
            // Make sure UIScene is running - in case it wasn't started or was stopped
            if (!this.scene.isActive('UIScene')) {
                console.log("Starting UIScene from GameScene");
                this.scene.launch('UIScene');
            }
            
            // Send initial events to update UI
            this.events.emit('updateShots', this.shotsRemaining);
            this.events.emit('updatePercentage', this.revealPercentage);
            
            console.log("GameScene created successfully");
        } catch (error) {
            console.error("Error in create:", error);
        }
    }
    
    // Initialize the BlockManager
    initializeBlockManager() {
        console.log("Initializing BlockManager...");
        try {
            // Create a new BlockManager instance
            this.blockManager = new BlockManager(this);
            
            // Create a reference to the block types
            this.BLOCK_TYPES = this.blockManager.BLOCK_TYPES;
            
            console.log("BlockManager initialized successfully with block types:", this.BLOCK_TYPES);
            return true;
        } catch (error) {
            console.error("Error initializing BlockManager:", error);
            
            // If BlockManager fails to initialize, set up fallback block types
            this.BLOCK_TYPES = {
                STANDARD: 'standard',
                STRONG: 'strong',
                DYNAMITE: 'dynamite',
                ETERNAL: 'eternal',
                BOUNCY: 'bouncy'
            };
            
            console.log("Using fallback block types due to BlockManager initialization failure");
            return false;
        }
    }

    setupCamera() {
        // Set up the main camera to show the entire 1920x1080 game area without overflow
        const gameWidth = 1920;
        const gameHeight = 1080;
        
        // Set strict bounds for the main camera
        this.cameras.main.setBounds(0, 0, gameWidth, gameHeight);
        this.cameras.main.setBackgroundColor('#000000');
        this.cameras.main.setViewport(0, 0, gameWidth, gameHeight);
        
        // Make sure the camera is properly scaled according to the game config
        const scaleX = this.scale.width / gameWidth;
        const scaleY = this.scale.height / gameHeight;
        
        console.log(`Camera setup: Game dimensions ${this.scale.width}x${this.scale.height}, Scale: ${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`);
        
        // Create a UI camera specifically for UI elements with highest depth
        this.uiCamera = this.cameras.add(0, 0, gameWidth, gameHeight);
        this.uiCamera.setName('UI Camera');
        this.uiCamera.setScroll(0, 0);
        this.uiCamera.setBackgroundColor(0x000000, 0); // Transparent background
        
        // Only include UI elements in this camera (depth >= UI_DEPTH)
        this.uiCamera.ignore(this.children.list.filter(item => item.depth < this.UI_DEPTH));
        
        // Ensure our world physics is larger than our camera bounds to prevent bombs from hitting invisible walls
        // Extend the physics world by 2000 pixels in each direction
        this.matter.world.setBounds(-2000, -2000, gameWidth + 4000, gameHeight + 4000);
        
        // Debug camera bounds if in debug mode
        if (this.debugMode) {
            console.log(`Main camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`UI camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`Physics world bounds: -2000, -2000, ${gameWidth + 4000}, ${gameHeight + 4000}`);
            console.log(`UI depth: ${this.UI_DEPTH}`);
        }
    }

    createBackground() {
        try {
            // Create a container with specific depth for layering
            this.backgroundContainer = this.add.container(0, 0);
            this.backgroundContainer.setDepth(0); // Lowest depth for background
            
            // Check if level background was loaded successfully
            let bgImage;
            if (this.textures.exists('levelBackground')) {
                // Use the loaded background image
                bgImage = this.add.image(1920/2, 1080/2, 'levelBackground');
                console.log("Using loaded level background image");
            } else {
                // Fallback to default background
                bgImage = this.add.image(1920/2, 1080/2, 'background');
                console.log("Fallback to default background");
            }
            
            // Set background to lowest depth to ensure it's behind everything
            bgImage.setDepth(0);
            
            // Position the chibi image on the right side of the screen
            // Use 2/3 of the screen width for X position to move it rightward
            const chibiX = Math.floor(1920 * 0.7); // 70% of screen width
            const chibiY = 1080/2; // Centered vertically
            
            // Add the chibi image - explicitly use chibi_girl1 as the key
            console.log("Loading chibi image with key: 'chibi_girl1'");
            this.chibiImage = this.add.image(chibiX, chibiY, 'chibi_girl1');
            this.chibiImage.setDepth(1); // Depth 1 for chibi image - blocks should be higher
            
            // Debug the loaded image
            console.log("Chibi image texture:", this.chibiImage.texture.key);
            console.log("Chibi image frame:", this.chibiImage.frame?.name || "default");
            
            // Use the image at its original size without any scaling
            this.chibiImage.setScale(1.0);
            
            // Set the image to be fully opaque
            this.chibiImage.setAlpha(1);
            
            // Store dimensions for later reference
            const chibiWidth = this.chibiImage.width;
            const chibiHeight = this.chibiImage.height;
            
            // Log the new position
            console.log("Background created with chibi image positioned at:", 
                        chibiX, chibiY,
                        "with dimensions:", chibiWidth, "x", chibiHeight);
        } catch (error) {
            console.error("Error in createBackground:", error);
        }
    }

    createIceBlocks() {
        this.iceBlocks = [];
        this.blueVeils = []; // Array to store individual blue veil rectangles
        const blockSize = 15; // Reduced to 1/4 of original size (was 60)
        
        // Create a container for ice blocks with depth above chibi but below UI
        const blocksContainer = this.add.container(0, 0);
        blocksContainer.setDepth(2);
        
        // Get the chibi image bounds with scaling applied
        const scale = this.chibiImage.scale; // Get actual scale being used
        const imageWidth = this.chibiImage.width; 
        const imageHeight = this.chibiImage.height;
        
        // Calculate the image boundaries
        const imageX = this.chibiImage.x - (imageWidth * scale) / 2;
        const imageY = this.chibiImage.y - (imageHeight * scale) / 2;
        
        // Calculate grid dimensions
        const cols = Math.ceil(imageWidth * scale / blockSize);
        const rows = Math.ceil(imageHeight * scale / blockSize);
        
        console.log(`Chibi image at ${this.chibiImage.x}, ${this.chibiImage.y}, scale: ${scale}`);
        console.log(`Image calculated bounds: ${imageX}, ${imageY}, ${imageWidth * scale}x${imageHeight * scale}`);
        console.log(`Creating ice blocks grid: ${cols}x${rows} over image area ${imageWidth * scale}x${imageHeight * scale}`);
        
        // Create a temporary canvas to check pixel data
        const tempCanvas = document.createElement('canvas');
        const tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = imageWidth;
        tempCanvas.height = imageHeight;
        
        // Get the texture key of the chibi image
        const textureKey = this.chibiImage.texture.key;
        
        // Get the image data
        const frame = this.textures.getFrame(textureKey);
        const source = frame.source.image || frame.source.canvas;
        
        // Draw the image to our temp canvas
        tempContext.drawImage(source, 0, 0, imageWidth, imageHeight);
        
        // Alpha threshold - lower value to include more semi-transparent pixels at edges
        const alphaThreshold = 50; // Much lower threshold to catch edge pixels
        
        // Sample size for checking multiple pixels in the block area
        const sampleSize = 5; // Check more points in a 5x5 grid
        const sampleOffset = Math.floor(blockSize / (sampleSize + 1) / scale);
        
        // Create a 2D grid to track where we've placed blocks
        const blockGrid = Array(rows).fill().map(() => Array(cols).fill(false));
        
        // Variables to track total blocks for percentage calculations
        this.totalIceBlocks = 0;
        this.clearedIceBlocks = 0;
        
        // First pass: Find all core pixels that meet the alpha threshold
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Sample multiple points within this block area
                let hasVisiblePixel = false;
                
                for (let sx = 0; sx < sampleSize; sx++) {
                    for (let sy = 0; sy < sampleSize; sy++) {
                        // Calculate sampling position in the original image
                        const offsetX = -Math.floor(sampleSize/2) + sx;
                        const offsetY = -Math.floor(sampleSize/2) + sy;
                        
                        const sampleX = Math.floor(col * blockSize / scale) + offsetX * sampleOffset;
                        const sampleY = Math.floor(row * blockSize / scale) + offsetY * sampleOffset;
                        
                        // Ensure we're within bounds
                        if (sampleX >= 0 && sampleX < imageWidth && 
                            sampleY >= 0 && sampleY < imageHeight) {
                            
                            try {
                                const pixelData = tempContext.getImageData(sampleX, sampleY, 1, 1).data;
                                // If any sampled pixel has alpha above threshold, mark block as visible
                                if (pixelData[3] >= alphaThreshold) {
                                    hasVisiblePixel = true;
                                    break;
                                }
                            } catch (e) {
                                console.error(`Error sampling pixel at ${sampleX},${sampleY}:`, e);
                            }
                        }
                    }
                    if (hasVisiblePixel) break;
                }
                
                if (hasVisiblePixel) {
                    blockGrid[row][col] = true;
                }
            }
        }
        
        // Second pass: Add padding around detected pixels to ensure edges are covered
        // This creates a thickness around the chibi image
        const paddingAmount = 1; // How many blocks of padding to add
        
        // Create a copy of the grid before adding padding
        const originalGrid = blockGrid.map(row => [...row]);
        
        // Add padding around each detected block
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (originalGrid[row][col]) {
                    // Add padding blocks around this block
                    for (let pr = -paddingAmount; pr <= paddingAmount; pr++) {
                        for (let pc = -paddingAmount; pc <= paddingAmount; pc++) {
                            const padRow = row + pr;
                            const padCol = col + pc;
                            
                            // Make sure we're in bounds
                            if (padRow >= 0 && padRow < rows && padCol >= 0 && padCol < cols) {
                                blockGrid[padRow][padCol] = true;
                            }
                        }
                    }
                }
            }
        }
        
        // Prepare to create exactly 3 dynamite blocks
        const dynamitePositions = [];
        const validPositions = [];
        
        // Collect all valid block positions first
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (blockGrid[row][col]) {
                    const blockScreenX = imageX + col * blockSize + blockSize / 2;
                    const blockScreenY = imageY + row * blockSize + blockSize / 2;
                    validPositions.push({x: blockScreenX, y: blockScreenY, row, col});
                }
            }
        }
        
        // Pick 3 random positions for dynamite blocks (if we have enough blocks)
        if (validPositions.length > 3) {
            // Shuffle the array to get random positions
            for (let i = validPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
            }
            
            // Take the first 3 positions for dynamite
            for (let i = 0; i < 3; i++) {
                dynamitePositions.push({
                    x: validPositions[i].x,
                    y: validPositions[i].y,
                    row: validPositions[i].row,
                    col: validPositions[i].col
                });
            }
        }
        
        // Third pass: Create blocks based on our grid
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (!blockGrid[row][col]) continue;
                
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Determine block type
                let blockType = 'standard'; // Default is standard
                
                // Check if this position is one of our dynamite positions
                const isDynamite = dynamitePositions.some(pos => 
                    pos.row === row && pos.col === col);
                
                if (isDynamite) {
                    blockType = 'dynamite';
                } else {
                    // For non-dynamite blocks, use weighted random for other special types
                    let blockTypeRand = Math.random();
                    if (blockTypeRand < 0.02) {
                        blockType = 'eternal';
                    } else if (blockTypeRand < 0.08) {
                        blockType = 'strong';
                    }
                }
                
                // Base physics properties
                let physicsProps = {
                    isStatic: true,
                    friction: 0.01, 
                    restitution: 0.3
                };
                
                // Adjust properties based on block type
                if (blockType === 'bouncy') {
                    physicsProps.restitution = 1.0; // Bouncy blocks have high restitution
                }
                
                // Create ice block
                const block = this.matter.add.image(blockScreenX, blockScreenY, 'iceBlock', null, physicsProps);
                
                // Scale the blocks to match the new size
                block.setScale(blockSize / 40); // Original ice block is 40x40, scale up
                
                // Set a slight random rotation for some blocks
                if (Math.random() < 0.3) {
                    block.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set blocks to appear above the chibi image with high depth
                block.setDepth(16); // Very high depth (higher than blue veils at 15)
                
                // Initialize block properties based on type
                block.isActive = true;
                block.blockType = blockType;
                
                // Set specific properties based on block type
                let veilColor, veilAlpha;
                
                switch(blockType) {
                    case 'eternal':
                        block.hitsLeft = 3;
                        veilColor = 0x3333cc; // Dark blue
                        veilAlpha = 0.9;
                        break;
                    case 'strong':
                        block.hitsLeft = 2;
                        veilColor = 0x6666dd; // Medium blue
                        veilAlpha = 0.85;
                        break;
                    case 'dynamite':
                        block.hitsLeft = 1;
                        veilColor = 0xdd3333; // Red
                        veilAlpha = 0.85;
                        // Add a bit of pulsing to the dynamite block
                        this.tweens.add({
                            targets: block,
                            alpha: 0.7,
                            yoyo: true,
                            repeat: -1,
                            duration: 600
                        });
                        break;
                    case 'bouncy': 
                        // This case is still used by boundary bouncy blocks
                        block.hitsLeft = 1;
                        veilColor = 0x00cc44; // Green color
                        veilAlpha = 0.9;
                        // Add pulsating effect like the boundary bouncy blocks
                        this.tweens.add({
                            targets: block,
                            alpha: { from: 0.5, to: 0.8 },
                            yoyo: true,
                            repeat: -1,
                            duration: 1500,
                            ease: 'Sine.easeInOut'
                        });
                        break;
                    default: // standard
                        block.hitsLeft = 1;
                        veilColor = 0xaaddff; // Default light blue
                        veilAlpha = 0.85;
                }
                
                block.setAlpha(0.5);
                
                // Create a blue veil rectangle for this block with type-specific color
                const blueVeil = this.add.rectangle(
                    blockScreenX, 
                    blockScreenY, 
                    blockSize, 
                    blockSize, 
                    veilColor,
                    veilAlpha
                );
                
                // Add an ice-like texture effect with highlights
                blueVeil.setStrokeStyle(2, 0xffffff, 0.3); // Add a subtle white border
                
                // Add a slight random rotation for a more natural ice look
                if (Math.random() < 0.5) {
                    blueVeil.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set the blue veil to appear above the chibi image with high depth
                blueVeil.setDepth(15); // Ensure very high depth for blue veils to be visible
                
                // Store reference to its corresponding blue veil in the block
                block.blueVeil = blueVeil;
                
                this.iceBlocks.push(block);
                this.blueVeils.push(blueVeil);
                
                this.createIceTextureEffect(blueVeil);
                
                // Count each ice block for percentage calculations
                this.totalIceBlocks++;
            }
        }
        
        // Ensure chibi image remains fully opaque after adding blue veils
        this.chibiImage.setAlpha(1);
        
        // Reset revealed pixels counter based on total ice blocks
        this.revealedPixels = 0;
        this.revealPercentage = 0;
        
        console.log(`Created ${this.iceBlocks.length} ice blocks with blue veils`);
        // Log the number of dynamite blocks created
        console.log(`Created exactly ${dynamitePositions.length} dynamite blocks`);
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }

    updateRevealPercentage() {
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        
        // Reposition slingshot to left side of screen
        this.SLINGSHOT_X = 300; // Keep at 300 (positioned on left side)
        this.SLINGSHOT_Y = 800; // Keep at same height
        this.MAX_DRAG_DISTANCE = 200;
        this.SHOT_POWER = 0.13; // Increased shot power (from 0.07)
        this.MAX_SHOTS = 10;
        this.shotsRemaining = this.MAX_SHOTS;
        this.isAiming = false;
        this.revealPercentage = 0;
        this.targetPercentage = 85;
        this.UI_DEPTH = 1000; // UI depth for consistent layering
        this.isLevelComplete = false;
        this.isGameOver = false;
        
        // Reference to block manager
        this.blockManager = null;
        
        // Add bomb state tracking to prevent stuck game state
        this.bombState = {
            active: false,
            lastResetTime: 0,
            lastBombFired: 0,
            pendingReset: null,
            maxIdleTime: 20000, // Auto-reset if bomb is idle for 20 seconds
            autoResetTimer: null
        };
        
        // Add developer method to refresh UI
        if (window) {
            window.refreshGameUI = () => {
                console.log('Forcing UI refresh...');
                if (this.bombSelectorContainer) {
                    this.bombSelectorContainer.destroy();
                    this.bombSelectorContainer = null;
                }
                this.createBombSelector();
                console.log('UI refreshed!');
                return 'UI refreshed successfully!';
            };
        }
        
        // Audio properties
        this.bgMusic = null;
        this.victoryMusic = null;
        
        // Bomb types with names from Game Design Document
        this.BOMB_TYPES = {
            BLAST: 'blast_bomb',
            PIERCER: 'piercer_bomb',
            CLUSTER: 'cluster_bomb',
            STICKY: 'sticky_bomb',
            SHATTERER: 'shatterer_bomb',
            DRILLER: 'driller_bomb'  // Add Driller Girl bomb type
        };
        
        // Bomb names based on Game Design Document
        this.BOMB_NAMES = {
            [this.BOMB_TYPES.BLAST]: 'Blast Girl',
            [this.BOMB_TYPES.PIERCER]: 'Piercer Girl',
            [this.BOMB_TYPES.CLUSTER]: 'Cluster Girl',
            [this.BOMB_TYPES.STICKY]: 'Sticky Girl',
            [this.BOMB_TYPES.SHATTERER]: 'Shatterer Girl',
            [this.BOMB_TYPES.DRILLER]: 'Driller Girl'  // Add Driller Girl name
        };
        
        // Remaining bombs of each type
        this.bombsRemaining = {
            [this.BOMB_TYPES.BLAST]: 3,
            [this.BOMB_TYPES.PIERCER]: 5,
            [this.BOMB_TYPES.CLUSTER]: 1,
            [this.BOMB_TYPES.STICKY]: 5,
            [this.BOMB_TYPES.SHATTERER]: 1,
            [this.BOMB_TYPES.DRILLER]: 3  // Add initial count for Driller Girl bombs
        };
        
        // Current selected bomb type
        this.currentBombType = this.BOMB_TYPES.BLAST;
        
        // Debug mode for testing
        this.debugMode = true;
        
        // Configure the game for better performance with frequent pixel operations
        this.willReadPixelsFrequently = true;
    }

    create() {
        try {
            // Clear any cached textures or game objects to ensure fresh UI
            this.game.textures.list = this.textures.list;
            
            // Setup camera to show the full 1920x1080 game world
            this.setupCamera();
            
            // Set zero gravity (world bounds are set in setupCamera)
            this.matter.world.setGravity(0, 0); // Zero gravity for space-like environment

            // Initialize arrays for game objects
            this.activeStickyBombs = [];
            
            // Create trajectoryPoints for aiming path
            this.trajectoryPoints = [];
            this.trajectoryGraphics = this.add.graphics();
            this.trajectoryGraphics.setDepth(15); // Higher depth than blocks (4) to ensure visibility
            
            // Create game objects
            this.createBackground();
            
            // Initialize the block manager
            this.initializeBlockManager();
            
            // Create the completion veil based on chibi image shape
            this.createCompletionVeil();
            
            // Create slingshot
            this.createSlingshot();
            this.createTargets();
            
            // Create UI before resetting bomb
            this.createUI();
            
            // Reset bomb and prepare for first shot
            this.resetBomb();
            
            // Setup input handlers
            this.setupInputHandlers();
            
            // Directly initialize audio (simpler approach)
            this.initializeAudio();
            
            // Create bouncy blocks boundary - removed
            // this.createBoundaryBouncyBlocks();
            
            // Setup global failsafe timer to detect stuck game states
            this.setupGlobalFailsafe();
            
            // Debug text display - moved to bottom of screen
            if (this.debugMode) {
                this.debugText = this.add.text(10, this.cameras.main.height - 30, 'Debug: Ready', { 
                    font: '16px Arial', 
                    fill: '#ffffff',
                    backgroundColor: '#333333',
                    padding: { x: 5, y: 2 }
                });
                this.debugText.setDepth(this.UI_DEPTH - 1); // Below UI but above game elements
            }
            
            // Make sure UIScene is running - in case it wasn't started or was stopped
            if (!this.scene.isActive('UIScene')) {
                console.log("Starting UIScene from GameScene");
                this.scene.launch('UIScene');
            }
            
            // Send initial events to update UI
            this.events.emit('updateShots', this.shotsRemaining);
            this.events.emit('updatePercentage', this.revealPercentage);
            
            console.log("GameScene created successfully");
        } catch (error) {
            console.error("Error in create:", error);
        }
    }
    
    // Initialize the BlockManager
    initializeBlockManager() {
        console.log("Initializing BlockManager...");
        try {
            // Create a new BlockManager instance
            this.blockManager = new BlockManager(this);
            
            // Create a reference to the block types
            this.BLOCK_TYPES = this.blockManager.BLOCK_TYPES;
            
            console.log("BlockManager initialized successfully with block types:", this.BLOCK_TYPES);
            return true;
        } catch (error) {
            console.error("Error initializing BlockManager:", error);
            
            // If BlockManager fails to initialize, set up fallback block types
            this.BLOCK_TYPES = {
                STANDARD: 'standard',
                STRONG: 'strong',
                DYNAMITE: 'dynamite',
                ETERNAL: 'eternal',
                BOUNCY: 'bouncy'
            };
            
            console.log("Using fallback block types due to BlockManager initialization failure");
            return false;
        }
    }

    setupCamera() {
        // Set up the main camera to show the entire 1920x1080 game area without overflow
        const gameWidth = 1920;
        const gameHeight = 1080;
        
        // Set strict bounds for the main camera
        this.cameras.main.setBounds(0, 0, gameWidth, gameHeight);
        this.cameras.main.setBackgroundColor('#000000');
        this.cameras.main.setViewport(0, 0, gameWidth, gameHeight);
        
        // Make sure the camera is properly scaled according to the game config
        const scaleX = this.scale.width / gameWidth;
        const scaleY = this.scale.height / gameHeight;
        
        console.log(`Camera setup: Game dimensions ${this.scale.width}x${this.scale.height}, Scale: ${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`);
        
        // Create a UI camera specifically for UI elements with highest depth
        this.uiCamera = this.cameras.add(0, 0, gameWidth, gameHeight);
        this.uiCamera.setName('UI Camera');
        this.uiCamera.setScroll(0, 0);
        this.uiCamera.setBackgroundColor(0x000000, 0); // Transparent background
        
        // Only include UI elements in this camera (depth >= UI_DEPTH)
        this.uiCamera.ignore(this.children.list.filter(item => item.depth < this.UI_DEPTH));
        
        // Ensure our world physics is larger than our camera bounds to prevent bombs from hitting invisible walls
        // Extend the physics world by 2000 pixels in each direction
        this.matter.world.setBounds(-2000, -2000, gameWidth + 4000, gameHeight + 4000);
        
        // Debug camera bounds if in debug mode
        if (this.debugMode) {
            console.log(`Main camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`UI camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`Physics world bounds: -2000, -2000, ${gameWidth + 4000}, ${gameHeight + 4000}`);
            console.log(`UI depth: ${this.UI_DEPTH}`);
        }
    }

    createBackground() {
        try {
            // Create a container with specific depth for layering
            this.backgroundContainer = this.add.container(0, 0);
            this.backgroundContainer.setDepth(0); // Lowest depth for background
            
            // Check if level background was loaded successfully
            let bgImage;
            if (this.textures.exists('levelBackground')) {
                // Use the loaded background image
                bgImage = this.add.image(1920/2, 1080/2, 'levelBackground');
                console.log("Using loaded level background image");
            } else {
                // Fallback to default background
                bgImage = this.add.image(1920/2, 1080/2, 'background');
                console.log("Fallback to default background");
            }
            
            // Set background to lowest depth to ensure it's behind everything
            bgImage.setDepth(0);
            
            // Position the chibi image on the right side of the screen
            // Use 2/3 of the screen width for X position to move it rightward
            const chibiX = Math.floor(1920 * 0.7); // 70% of screen width
            const chibiY = 1080/2; // Centered vertically
            
            // Add the chibi image - explicitly use chibi_girl1 as the key
            console.log("Loading chibi image with key: 'chibi_girl1'");
            this.chibiImage = this.add.image(chibiX, chibiY, 'chibi_girl1');
            this.chibiImage.setDepth(1); // Depth 1 for chibi image - blocks should be higher
            
            // Debug the loaded image
            console.log("Chibi image texture:", this.chibiImage.texture.key);
            console.log("Chibi image frame:", this.chibiImage.frame?.name || "default");
            
            // Use the image at its original size without any scaling
            this.chibiImage.setScale(1.0);
            
            // Set the image to be fully opaque
            this.chibiImage.setAlpha(1);
            
            // Store dimensions for later reference
            const chibiWidth = this.chibiImage.width;
            const chibiHeight = this.chibiImage.height;
            
            // Log the new position
            console.log("Background created with chibi image positioned at:", 
                        chibiX, chibiY,
                        "with dimensions:", chibiWidth, "x", chibiHeight);
        } catch (error) {
            console.error("Error in createBackground:", error);
        }
    }

    createIceBlocks() {
        this.iceBlocks = [];
        this.blueVeils = []; // Array to store individual blue veil rectangles
        const blockSize = 15; // Reduced to 1/4 of original size (was 60)
        
        // Create a container for ice blocks with depth above chibi but below UI
        const blocksContainer = this.add.container(0, 0);
        blocksContainer.setDepth(2);
        
        // Get the chibi image bounds with scaling applied
        const scale = this.chibiImage.scale; // Get actual scale being used
        const imageWidth = this.chibiImage.width; 
        const imageHeight = this.chibiImage.height;
        
        // Calculate the image boundaries
        const imageX = this.chibiImage.x - (imageWidth * scale) / 2;
        const imageY = this.chibiImage.y - (imageHeight * scale) / 2;
        
        // Calculate grid dimensions
        const cols = Math.ceil(imageWidth * scale / blockSize);
        const rows = Math.ceil(imageHeight * scale / blockSize);
        
        console.log(`Chibi image at ${this.chibiImage.x}, ${this.chibiImage.y}, scale: ${scale}`);
        console.log(`Image calculated bounds: ${imageX}, ${imageY}, ${imageWidth * scale}x${imageHeight * scale}`);
        console.log(`Creating ice blocks grid: ${cols}x${rows} over image area ${imageWidth * scale}x${imageHeight * scale}`);
        
        // Create a temporary canvas to check pixel data
        const tempCanvas = document.createElement('canvas');
        const tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = imageWidth;
        tempCanvas.height = imageHeight;
        
        // Get the texture key of the chibi image
        const textureKey = this.chibiImage.texture.key;
        
        // Get the image data
        const frame = this.textures.getFrame(textureKey);
        const source = frame.source.image || frame.source.canvas;
        
        // Draw the image to our temp canvas
        tempContext.drawImage(source, 0, 0, imageWidth, imageHeight);
        
        // Alpha threshold - lower value to include more semi-transparent pixels at edges
        const alphaThreshold = 50; // Much lower threshold to catch edge pixels
        
        // Sample size for checking multiple pixels in the block area
        const sampleSize = 5; // Check more points in a 5x5 grid
        const sampleOffset = Math.floor(blockSize / (sampleSize + 1) / scale);
        
        // Create a 2D grid to track where we've placed blocks
        const blockGrid = Array(rows).fill().map(() => Array(cols).fill(false));
        
        // Variables to track total blocks for percentage calculations
        this.totalIceBlocks = 0;
        this.clearedIceBlocks = 0;
        
        // First pass: Find all core pixels that meet the alpha threshold
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Sample multiple points within this block area
                let hasVisiblePixel = false;
                
                for (let sx = 0; sx < sampleSize; sx++) {
                    for (let sy = 0; sy < sampleSize; sy++) {
                        // Calculate sampling position in the original image
                        const offsetX = -Math.floor(sampleSize/2) + sx;
                        const offsetY = -Math.floor(sampleSize/2) + sy;
                        
                        const sampleX = Math.floor(col * blockSize / scale) + offsetX * sampleOffset;
                        const sampleY = Math.floor(row * blockSize / scale) + offsetY * sampleOffset;
                        
                        // Ensure we're within bounds
                        if (sampleX >= 0 && sampleX < imageWidth && 
                            sampleY >= 0 && sampleY < imageHeight) {
                            
                            try {
                                const pixelData = tempContext.getImageData(sampleX, sampleY, 1, 1).data;
                                // If any sampled pixel has alpha above threshold, mark block as visible
                                if (pixelData[3] >= alphaThreshold) {
                                    hasVisiblePixel = true;
                                    break;
                                }
                            } catch (e) {
                                console.error(`Error sampling pixel at ${sampleX},${sampleY}:`, e);
                            }
                        }
                    }
                    if (hasVisiblePixel) break;
                }
                
                if (hasVisiblePixel) {
                    blockGrid[row][col] = true;
                }
            }
        }
        
        // Second pass: Add padding around detected pixels to ensure edges are covered
        // This creates a thickness around the chibi image
        const paddingAmount = 1; // How many blocks of padding to add
        
        // Create a copy of the grid before adding padding
        const originalGrid = blockGrid.map(row => [...row]);
        
        // Add padding around each detected block
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (originalGrid[row][col]) {
                    // Add padding blocks around this block
                    for (let pr = -paddingAmount; pr <= paddingAmount; pr++) {
                        for (let pc = -paddingAmount; pc <= paddingAmount; pc++) {
                            const padRow = row + pr;
                            const padCol = col + pc;
                            
                            // Make sure we're in bounds
                            if (padRow >= 0 && padRow < rows && padCol >= 0 && padCol < cols) {
                                blockGrid[padRow][padCol] = true;
                            }
                        }
                    }
                }
            }
        }
        
        // Prepare to create exactly 3 dynamite blocks
        const dynamitePositions = [];
        const validPositions = [];
        
        // Collect all valid block positions first
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (blockGrid[row][col]) {
                    const blockScreenX = imageX + col * blockSize + blockSize / 2;
                    const blockScreenY = imageY + row * blockSize + blockSize / 2;
                    validPositions.push({x: blockScreenX, y: blockScreenY, row, col});
                }
            }
        }
        
        // Pick 3 random positions for dynamite blocks (if we have enough blocks)
        if (validPositions.length > 3) {
            // Shuffle the array to get random positions
            for (let i = validPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
            }
            
            // Take the first 3 positions for dynamite
            for (let i = 0; i < 3; i++) {
                dynamitePositions.push({
                    x: validPositions[i].x,
                    y: validPositions[i].y,
                    row: validPositions[i].row,
                    col: validPositions[i].col
                });
            }
        }
        
        // Third pass: Create blocks based on our grid
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (!blockGrid[row][col]) continue;
                
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Determine block type
                let blockType = 'standard'; // Default is standard
                
                // Check if this position is one of our dynamite positions
                const isDynamite = dynamitePositions.some(pos => 
                    pos.row === row && pos.col === col);
                
                if (isDynamite) {
                    blockType = 'dynamite';
                } else {
                    // For non-dynamite blocks, use weighted random for other special types
                    let blockTypeRand = Math.random();
                    if (blockTypeRand < 0.02) {
                        blockType = 'eternal';
                    } else if (blockTypeRand < 0.08) {
                        blockType = 'strong';
                    }
                }
                
                // Base physics properties
                let physicsProps = {
                    isStatic: true,
                    friction: 0.01, 
                    restitution: 0.3
                };
                
                // Adjust properties based on block type
                if (blockType === 'bouncy') {
                    physicsProps.restitution = 1.0; // Bouncy blocks have high restitution
                }
                
                // Create ice block
                const block = this.matter.add.image(blockScreenX, blockScreenY, 'iceBlock', null, physicsProps);
                
                // Scale the blocks to match the new size
                block.setScale(blockSize / 40); // Original ice block is 40x40, scale up
                
                // Set a slight random rotation for some blocks
                if (Math.random() < 0.3) {
                    block.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set blocks to appear above the chibi image with high depth
                block.setDepth(16); // Very high depth (higher than blue veils at 15)
                
                // Initialize block properties based on type
                block.isActive = true;
                block.blockType = blockType;
                
                // Set specific properties based on block type
                let veilColor, veilAlpha;
                
                switch(blockType) {
                    case 'eternal':
                        block.hitsLeft = 3;
                        veilColor = 0x3333cc; // Dark blue
                        veilAlpha = 0.9;
                        break;
                    case 'strong':
                        block.hitsLeft = 2;
                        veilColor = 0x6666dd; // Medium blue
                        veilAlpha = 0.85;
                        break;
                    case 'dynamite':
                        block.hitsLeft = 1;
                        veilColor = 0xdd3333; // Red
                        veilAlpha = 0.85;
                        // Add a bit of pulsing to the dynamite block
                        this.tweens.add({
                            targets: block,
                            alpha: 0.7,
                            yoyo: true,
                            repeat: -1,
                            duration: 600
                        });
                        break;
                    case 'bouncy': 
                        // This case is still used by boundary bouncy blocks
                        block.hitsLeft = 1;
                        veilColor = 0x00cc44; // Green color
                        veilAlpha = 0.9;
                        // Add pulsating effect like the boundary bouncy blocks
                        this.tweens.add({
                            targets: block,
                            alpha: { from: 0.5, to: 0.8 },
                            yoyo: true,
                            repeat: -1,
                            duration: 1500,
                            ease: 'Sine.easeInOut'
                        });
                        break;
                    default: // standard
                        block.hitsLeft = 1;
                        veilColor = 0xaaddff; // Default light blue
                        veilAlpha = 0.85;
                }
                
                block.setAlpha(0.5);
                
                // Create a blue veil rectangle for this block with type-specific color
                const blueVeil = this.add.rectangle(
                    blockScreenX, 
                    blockScreenY, 
                    blockSize, 
                    blockSize, 
                    veilColor,
                    veilAlpha
                );
                
                // Add an ice-like texture effect with highlights
                blueVeil.setStrokeStyle(2, 0xffffff, 0.3); // Add a subtle white border
                
                // Add a slight random rotation for a more natural ice look
                if (Math.random() < 0.5) {
                    blueVeil.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set the blue veil to appear above the chibi image with high depth
                blueVeil.setDepth(15); // Ensure very high depth for blue veils to be visible
                
                // Store reference to its corresponding blue veil in the block
                block.blueVeil = blueVeil;
                
                this.iceBlocks.push(block);
                this.blueVeils.push(blueVeil);
                
                this.createIceTextureEffect(blueVeil);
                
                // Count each ice block for percentage calculations
                this.totalIceBlocks++;
            }
        }
        
        // Ensure chibi image remains fully opaque after adding blue veils
        this.chibiImage.setAlpha(1);
        
        // Reset revealed pixels counter based on total ice blocks
        this.revealedPixels = 0;
        this.revealPercentage = 0;
        
        console.log(`Created ${this.iceBlocks.length} ice blocks with blue veils`);
        // Log the number of dynamite blocks created
        console.log(`Created exactly ${dynamitePositions.length} dynamite blocks`);
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                console.log(`Collision detected with ${pairs.length} pairs`);
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Simple explosion at bomb position
                        this.createExplosion(this.bomb.x, this.bomb.y);
                        
                        // Simple approach: Just use loops to find and destroy blocks near the explosion
                        let radius = 150; // Default radius
                        
                        // Adjust radius based on bomb type
                        if (bombType === this.BOMB_TYPES.CLUSTER) radius = 100;
                        if (bombType === this.BOMB_TYPES.SHATTERER) radius = 200;
                        
                        // Directly destroy blocks
                        this.iceBlocks.forEach(block => {
                            if (block && block.isActive) {
                                const distance = Phaser.Math.Distance.Between(
                                    this.bomb.x, this.bomb.y, 
                                    block.x, block.y
                                );
                                
                                if (distance < radius) {
                                    // Use the direct destroy method from BlockManager
                                    if (this.blockManager) {
                                        this.blockManager.directDestroyBlock(block);
                                    } else {
                                        // Mark as inactive
                                        block.isActive = false;
                                        
                                        // Remove from array next frame
                                        setTimeout(() => {
                                            const index = this.iceBlocks.indexOf(block);
                                            if (index !== -1) {
                                                this.iceBlocks.splice(index, 1);
                                            }
                                        }, 0);
                                    }
                                }
                            }
                        });
                        
                        // Update UI
                        this.revealPercentage = Math.min(100, Math.floor(
                            ((this.initialBlockCount - this.iceBlocks.length) / this.initialBlockCount) * 100
                        ));
                        this.events.emit('updatePercentage', this.revealPercentage);
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simple collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        
        // Reposition slingshot to left side of screen
        this.SLINGSHOT_X = 300; // Keep at 300 (positioned on left side)
        this.SLINGSHOT_Y = 800; // Keep at same height
        this.MAX_DRAG_DISTANCE = 200;
        this.SHOT_POWER = 0.13; // Increased shot power (from 0.07)
        this.MAX_SHOTS = 10;
        this.shotsRemaining = this.MAX_SHOTS;
        this.isAiming = false;
        this.revealPercentage = 0;
        this.targetPercentage = 85;
        this.UI_DEPTH = 1000; // UI depth for consistent layering
        this.isLevelComplete = false;
        this.isGameOver = false;
        
        // Reference to block manager
        this.blockManager = null;
        
        // Add bomb state tracking to prevent stuck game state
        this.bombState = {
            active: false,
            lastResetTime: 0,
            lastBombFired: 0,
            pendingReset: null,
            maxIdleTime: 20000, // Auto-reset if bomb is idle for 20 seconds
            autoResetTimer: null
        };
        
        // Add developer method to refresh UI
        if (window) {
            window.refreshGameUI = () => {
                console.log('Forcing UI refresh...');
                if (this.bombSelectorContainer) {
                    this.bombSelectorContainer.destroy();
                    this.bombSelectorContainer = null;
                }
                this.createBombSelector();
                console.log('UI refreshed!');
                return 'UI refreshed successfully!';
            };
        }
        
        // Audio properties
        this.bgMusic = null;
        this.victoryMusic = null;
        
        // Bomb types with names from Game Design Document
        this.BOMB_TYPES = {
            BLAST: 'blast_bomb',
            PIERCER: 'piercer_bomb',
            CLUSTER: 'cluster_bomb',
            STICKY: 'sticky_bomb',
            SHATTERER: 'shatterer_bomb',
            DRILLER: 'driller_bomb'  // Add Driller Girl bomb type
        };
        
        // Bomb names based on Game Design Document
        this.BOMB_NAMES = {
            [this.BOMB_TYPES.BLAST]: 'Blast Girl',
            [this.BOMB_TYPES.PIERCER]: 'Piercer Girl',
            [this.BOMB_TYPES.CLUSTER]: 'Cluster Girl',
            [this.BOMB_TYPES.STICKY]: 'Sticky Girl',
            [this.BOMB_TYPES.SHATTERER]: 'Shatterer Girl',
            [this.BOMB_TYPES.DRILLER]: 'Driller Girl'  // Add Driller Girl name
        };
        
        // Remaining bombs of each type
        this.bombsRemaining = {
            [this.BOMB_TYPES.BLAST]: 3,
            [this.BOMB_TYPES.PIERCER]: 5,
            [this.BOMB_TYPES.CLUSTER]: 1,
            [this.BOMB_TYPES.STICKY]: 5,
            [this.BOMB_TYPES.SHATTERER]: 1,
            [this.BOMB_TYPES.DRILLER]: 3  // Add initial count for Driller Girl bombs
        };
        
        // Current selected bomb type
        this.currentBombType = this.BOMB_TYPES.BLAST;
        
        // Debug mode for testing
        this.debugMode = true;
        
        // Configure the game for better performance with frequent pixel operations
        this.willReadPixelsFrequently = true;
    }

    create() {
        try {
            // Clear any cached textures or game objects to ensure fresh UI
            this.game.textures.list = this.textures.list;
            
            // Setup camera to show the full 1920x1080 game world
            this.setupCamera();
            
            // Set zero gravity (world bounds are set in setupCamera)
            this.matter.world.setGravity(0, 0); // Zero gravity for space-like environment

            // Initialize arrays for game objects
            this.activeStickyBombs = [];
            
            // Create trajectoryPoints for aiming path
            this.trajectoryPoints = [];
            this.trajectoryGraphics = this.add.graphics();
            this.trajectoryGraphics.setDepth(15); // Higher depth than blocks (4) to ensure visibility
            
            // Create game objects
            this.createBackground();
            
            // Initialize the block manager
            this.initializeBlockManager();
            
            // Create the completion veil based on chibi image shape
            this.createCompletionVeil();
            
            // Create slingshot
            this.createSlingshot();
            this.createTargets();
            
            // Create UI before resetting bomb
            this.createUI();
            
            // Reset bomb and prepare for first shot
            this.resetBomb();
            
            // Setup input handlers
            this.setupInputHandlers();
            
            // Directly initialize audio (simpler approach)
            this.initializeAudio();
            
            // Create bouncy blocks boundary - removed
            // this.createBoundaryBouncyBlocks();
            
            // Setup global failsafe timer to detect stuck game states
            this.setupGlobalFailsafe();
            
            // Debug text display - moved to bottom of screen
            if (this.debugMode) {
                this.debugText = this.add.text(10, this.cameras.main.height - 30, 'Debug: Ready', { 
                    font: '16px Arial', 
                    fill: '#ffffff',
                    backgroundColor: '#333333',
                    padding: { x: 5, y: 2 }
                });
                this.debugText.setDepth(this.UI_DEPTH - 1); // Below UI but above game elements
            }
            
            // Make sure UIScene is running - in case it wasn't started or was stopped
            if (!this.scene.isActive('UIScene')) {
                console.log("Starting UIScene from GameScene");
                this.scene.launch('UIScene');
            }
            
            // Send initial events to update UI
            this.events.emit('updateShots', this.shotsRemaining);
            this.events.emit('updatePercentage', this.revealPercentage);
            
            console.log("GameScene created successfully");
        } catch (error) {
            console.error("Error in create:", error);
        }
    }
    
    // Initialize the BlockManager
    initializeBlockManager() {
        console.log("Initializing BlockManager...");
        try {
            // Create a new BlockManager instance
            this.blockManager = new BlockManager(this);
            
            // Create a reference to the block types
            this.BLOCK_TYPES = this.blockManager.BLOCK_TYPES;
            
            console.log("BlockManager initialized successfully with block types:", this.BLOCK_TYPES);
            return true;
        } catch (error) {
            console.error("Error initializing BlockManager:", error);
            
            // If BlockManager fails to initialize, set up fallback block types
            this.BLOCK_TYPES = {
                STANDARD: 'standard',
                STRONG: 'strong',
                DYNAMITE: 'dynamite',
                ETERNAL: 'eternal',
                BOUNCY: 'bouncy'
            };
            
            console.log("Using fallback block types due to BlockManager initialization failure");
            return false;
        }
    }

    setupCamera() {
        // Set up the main camera to show the entire 1920x1080 game area without overflow
        const gameWidth = 1920;
        const gameHeight = 1080;
        
        // Set strict bounds for the main camera
        this.cameras.main.setBounds(0, 0, gameWidth, gameHeight);
        this.cameras.main.setBackgroundColor('#000000');
        this.cameras.main.setViewport(0, 0, gameWidth, gameHeight);
        
        // Make sure the camera is properly scaled according to the game config
        const scaleX = this.scale.width / gameWidth;
        const scaleY = this.scale.height / gameHeight;
        
        console.log(`Camera setup: Game dimensions ${this.scale.width}x${this.scale.height}, Scale: ${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`);
        
        // Create a UI camera specifically for UI elements with highest depth
        this.uiCamera = this.cameras.add(0, 0, gameWidth, gameHeight);
        this.uiCamera.setName('UI Camera');
        this.uiCamera.setScroll(0, 0);
        this.uiCamera.setBackgroundColor(0x000000, 0); // Transparent background
        
        // Only include UI elements in this camera (depth >= UI_DEPTH)
        this.uiCamera.ignore(this.children.list.filter(item => item.depth < this.UI_DEPTH));
        
        // Ensure our world physics is larger than our camera bounds to prevent bombs from hitting invisible walls
        // Extend the physics world by 2000 pixels in each direction
        this.matter.world.setBounds(-2000, -2000, gameWidth + 4000, gameHeight + 4000);
        
        // Debug camera bounds if in debug mode
        if (this.debugMode) {
            console.log(`Main camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`UI camera bounds: 0, 0, ${gameWidth}, ${gameHeight}`);
            console.log(`Physics world bounds: -2000, -2000, ${gameWidth + 4000}, ${gameHeight + 4000}`);
            console.log(`UI depth: ${this.UI_DEPTH}`);
        }
    }

    createBackground() {
        try {
            // Create a container with specific depth for layering
            this.backgroundContainer = this.add.container(0, 0);
            this.backgroundContainer.setDepth(0); // Lowest depth for background
            
            // Check if level background was loaded successfully
            let bgImage;
            if (this.textures.exists('levelBackground')) {
                // Use the loaded background image
                bgImage = this.add.image(1920/2, 1080/2, 'levelBackground');
                console.log("Using loaded level background image");
            } else {
                // Fallback to default background
                bgImage = this.add.image(1920/2, 1080/2, 'background');
                console.log("Fallback to default background");
            }
            
            // Set background to lowest depth to ensure it's behind everything
            bgImage.setDepth(0);
            
            // Position the chibi image on the right side of the screen
            // Use 2/3 of the screen width for X position to move it rightward
            const chibiX = Math.floor(1920 * 0.7); // 70% of screen width
            const chibiY = 1080/2; // Centered vertically
            
            // Add the chibi image - explicitly use chibi_girl1 as the key
            console.log("Loading chibi image with key: 'chibi_girl1'");
            this.chibiImage = this.add.image(chibiX, chibiY, 'chibi_girl1');
            this.chibiImage.setDepth(1); // Depth 1 for chibi image - blocks should be higher
            
            // Debug the loaded image
            console.log("Chibi image texture:", this.chibiImage.texture.key);
            console.log("Chibi image frame:", this.chibiImage.frame?.name || "default");
            
            // Use the image at its original size without any scaling
            this.chibiImage.setScale(1.0);
            
            // Set the image to be fully opaque
            this.chibiImage.setAlpha(1);
            
            // Store dimensions for later reference
            const chibiWidth = this.chibiImage.width;
            const chibiHeight = this.chibiImage.height;
            
            // Log the new position
            console.log("Background created with chibi image positioned at:", 
                        chibiX, chibiY,
                        "with dimensions:", chibiWidth, "x", chibiHeight);
        } catch (error) {
            console.error("Error in createBackground:", error);
        }
    }

    createIceBlocks() {
        this.iceBlocks = [];
        this.blueVeils = []; // Array to store individual blue veil rectangles
        const blockSize = 15; // Reduced to 1/4 of original size (was 60)
        
        // Create a container for ice blocks with depth above chibi but below UI
        const blocksContainer = this.add.container(0, 0);
        blocksContainer.setDepth(2);
        
        // Get the chibi image bounds with scaling applied
        const scale = this.chibiImage.scale; // Get actual scale being used
        const imageWidth = this.chibiImage.width; 
        const imageHeight = this.chibiImage.height;
        
        // Calculate the image boundaries
        const imageX = this.chibiImage.x - (imageWidth * scale) / 2;
        const imageY = this.chibiImage.y - (imageHeight * scale) / 2;
        
        // Calculate grid dimensions
        const cols = Math.ceil(imageWidth * scale / blockSize);
        const rows = Math.ceil(imageHeight * scale / blockSize);
        
        console.log(`Chibi image at ${this.chibiImage.x}, ${this.chibiImage.y}, scale: ${scale}`);
        console.log(`Image calculated bounds: ${imageX}, ${imageY}, ${imageWidth * scale}x${imageHeight * scale}`);
        console.log(`Creating ice blocks grid: ${cols}x${rows} over image area ${imageWidth * scale}x${imageHeight * scale}`);
        
        // Create a temporary canvas to check pixel data
        const tempCanvas = document.createElement('canvas');
        const tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = imageWidth;
        tempCanvas.height = imageHeight;
        
        // Get the texture key of the chibi image
        const textureKey = this.chibiImage.texture.key;
        
        // Get the image data
        const frame = this.textures.getFrame(textureKey);
        const source = frame.source.image || frame.source.canvas;
        
        // Draw the image to our temp canvas
        tempContext.drawImage(source, 0, 0, imageWidth, imageHeight);
        
        // Alpha threshold - lower value to include more semi-transparent pixels at edges
        const alphaThreshold = 50; // Much lower threshold to catch edge pixels
        
        // Sample size for checking multiple pixels in the block area
        const sampleSize = 5; // Check more points in a 5x5 grid
        const sampleOffset = Math.floor(blockSize / (sampleSize + 1) / scale);
        
        // Create a 2D grid to track where we've placed blocks
        const blockGrid = Array(rows).fill().map(() => Array(cols).fill(false));
        
        // Variables to track total blocks for percentage calculations
        this.totalIceBlocks = 0;
        this.clearedIceBlocks = 0;
        
        // First pass: Find all core pixels that meet the alpha threshold
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Sample multiple points within this block area
                let hasVisiblePixel = false;
                
                for (let sx = 0; sx < sampleSize; sx++) {
                    for (let sy = 0; sy < sampleSize; sy++) {
                        // Calculate sampling position in the original image
                        const offsetX = -Math.floor(sampleSize/2) + sx;
                        const offsetY = -Math.floor(sampleSize/2) + sy;
                        
                        const sampleX = Math.floor(col * blockSize / scale) + offsetX * sampleOffset;
                        const sampleY = Math.floor(row * blockSize / scale) + offsetY * sampleOffset;
                        
                        // Ensure we're within bounds
                        if (sampleX >= 0 && sampleX < imageWidth && 
                            sampleY >= 0 && sampleY < imageHeight) {
                            
                            try {
                                const pixelData = tempContext.getImageData(sampleX, sampleY, 1, 1).data;
                                // If any sampled pixel has alpha above threshold, mark block as visible
                                if (pixelData[3] >= alphaThreshold) {
                                    hasVisiblePixel = true;
                                    break;
                                }
                            } catch (e) {
                                console.error(`Error sampling pixel at ${sampleX},${sampleY}:`, e);
                            }
                        }
                    }
                    if (hasVisiblePixel) break;
                }
                
                if (hasVisiblePixel) {
                    blockGrid[row][col] = true;
                }
            }
        }
        
        // Second pass: Add padding around detected pixels to ensure edges are covered
        // This creates a thickness around the chibi image
        const paddingAmount = 1; // How many blocks of padding to add
        
        // Create a copy of the grid before adding padding
        const originalGrid = blockGrid.map(row => [...row]);
        
        // Add padding around each detected block
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (originalGrid[row][col]) {
                    // Add padding blocks around this block
                    for (let pr = -paddingAmount; pr <= paddingAmount; pr++) {
                        for (let pc = -paddingAmount; pc <= paddingAmount; pc++) {
                            const padRow = row + pr;
                            const padCol = col + pc;
                            
                            // Make sure we're in bounds
                            if (padRow >= 0 && padRow < rows && padCol >= 0 && padCol < cols) {
                                blockGrid[padRow][padCol] = true;
                            }
                        }
                    }
                }
            }
        }
        
        // Prepare to create exactly 3 dynamite blocks
        const dynamitePositions = [];
        const validPositions = [];
        
        // Collect all valid block positions first
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (blockGrid[row][col]) {
                    const blockScreenX = imageX + col * blockSize + blockSize / 2;
                    const blockScreenY = imageY + row * blockSize + blockSize / 2;
                    validPositions.push({x: blockScreenX, y: blockScreenY, row, col});
                }
            }
        }
        
        // Pick 3 random positions for dynamite blocks (if we have enough blocks)
        if (validPositions.length > 3) {
            // Shuffle the array to get random positions
            for (let i = validPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [validPositions[i], validPositions[j]] = [validPositions[j], validPositions[i]];
            }
            
            // Take the first 3 positions for dynamite
            for (let i = 0; i < 3; i++) {
                dynamitePositions.push({
                    x: validPositions[i].x,
                    y: validPositions[i].y,
                    row: validPositions[i].row,
                    col: validPositions[i].col
                });
            }
        }
        
        // Third pass: Create blocks based on our grid
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (!blockGrid[row][col]) continue;
                
                // Calculate screen position for the block
                const blockScreenX = imageX + col * blockSize + blockSize / 2;
                const blockScreenY = imageY + row * blockSize + blockSize / 2;
                
                // Determine block type
                let blockType = 'standard'; // Default is standard
                
                // Check if this position is one of our dynamite positions
                const isDynamite = dynamitePositions.some(pos => 
                    pos.row === row && pos.col === col);
                
                if (isDynamite) {
                    blockType = 'dynamite';
                } else {
                    // For non-dynamite blocks, use weighted random for other special types
                    let blockTypeRand = Math.random();
                    if (blockTypeRand < 0.02) {
                        blockType = 'eternal';
                    } else if (blockTypeRand < 0.08) {
                        blockType = 'strong';
                    }
                }
                
                // Base physics properties
                let physicsProps = {
                    isStatic: true,
                    friction: 0.01, 
                    restitution: 0.3
                };
                
                // Adjust properties based on block type
                if (blockType === 'bouncy') {
                    physicsProps.restitution = 1.0; // Bouncy blocks have high restitution
                }
                
                // Create ice block
                const block = this.matter.add.image(blockScreenX, blockScreenY, 'iceBlock', null, physicsProps);
                
                // Scale the blocks to match the new size
                block.setScale(blockSize / 40); // Original ice block is 40x40, scale up
                
                // Set a slight random rotation for some blocks
                if (Math.random() < 0.3) {
                    block.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set blocks to appear above the chibi image with high depth
                block.setDepth(16); // Very high depth (higher than blue veils at 15)
                
                // Initialize block properties based on type
                block.isActive = true;
                block.blockType = blockType;
                
                // Set specific properties based on block type
                let veilColor, veilAlpha;
                
                switch(blockType) {
                    case 'eternal':
                        block.hitsLeft = 3;
                        veilColor = 0x3333cc; // Dark blue
                        veilAlpha = 0.9;
                        break;
                    case 'strong':
                        block.hitsLeft = 2;
                        veilColor = 0x6666dd; // Medium blue
                        veilAlpha = 0.85;
                        break;
                    case 'dynamite':
                        block.hitsLeft = 1;
                        veilColor = 0xdd3333; // Red
                        veilAlpha = 0.85;
                        // Add a bit of pulsing to the dynamite block
                        this.tweens.add({
                            targets: block,
                            alpha: 0.7,
                            yoyo: true,
                            repeat: -1,
                            duration: 600
                        });
                        break;
                    case 'bouncy': 
                        // This case is still used by boundary bouncy blocks
                        block.hitsLeft = 1;
                        veilColor = 0x00cc44; // Green color
                        veilAlpha = 0.9;
                        // Add pulsating effect like the boundary bouncy blocks
                        this.tweens.add({
                            targets: block,
                            alpha: { from: 0.5, to: 0.8 },
                            yoyo: true,
                            repeat: -1,
                            duration: 1500,
                            ease: 'Sine.easeInOut'
                        });
                        break;
                    default: // standard
                        block.hitsLeft = 1;
                        veilColor = 0xaaddff; // Default light blue
                        veilAlpha = 0.85;
                }
                
                block.setAlpha(0.5);
                
                // Create a blue veil rectangle for this block with type-specific color
                const blueVeil = this.add.rectangle(
                    blockScreenX, 
                    blockScreenY, 
                    blockSize, 
                    blockSize, 
                    veilColor,
                    veilAlpha
                );
                
                // Add an ice-like texture effect with highlights
                blueVeil.setStrokeStyle(2, 0xffffff, 0.3); // Add a subtle white border
                
                // Add a slight random rotation for a more natural ice look
                if (Math.random() < 0.5) {
                    blueVeil.setRotation(Math.random() * 0.2 - 0.1);
                }
                
                // Set the blue veil to appear above the chibi image with high depth
                blueVeil.setDepth(15); // Ensure very high depth for blue veils to be visible
                
                // Store reference to its corresponding blue veil in the block
                block.blueVeil = blueVeil;
                
                this.iceBlocks.push(block);
                this.blueVeils.push(blueVeil);
                
                this.createIceTextureEffect(blueVeil);
                
                // Count each ice block for percentage calculations
                this.totalIceBlocks++;
            }
        }
        
        // Ensure chibi image remains fully opaque after adding blue veils
        this.chibiImage.setAlpha(1);
        
        // Reset revealed pixels counter based on total ice blocks
        this.revealedPixels = 0;
        this.revealPercentage = 0;
        
        console.log(`Created ${this.iceBlocks.length} ice blocks with blue veils`);
        // Log the number of dynamite blocks created
        console.log(`Created exactly ${dynamitePositions.length} dynamite blocks`);
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Handle the bomb explosion based on type
                        switch(bombType) {
                            case this.BOMB_TYPES.BLAST:
                                // Standard explosion with radius damage
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                                
                            case this.BOMB_TYPES.PIERCER:
                                // Creates a line of destruction in its direction
                                this.handlePiercerBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.CLUSTER:
                                // Creates multiple smaller explosions
                                this.handleClusterBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.STICKY:
                                // Sticks to a block and explodes after delay
                                // Simplify by using a direct explosion
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                                
                            case this.BOMB_TYPES.SHATTERER:
                                // Creates a powerful blast
                                this.handleShattererBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.DRILLER:
                                // Handle driller bomb
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 180);
                                break;
                                
                            default:
                                // Fallback to standard explosion
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                        }
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simplified collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Handle the bomb explosion based on type
                        switch(bombType) {
                            case this.BOMB_TYPES.BLAST:
                                // Standard explosion with radius damage
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                                
                            case this.BOMB_TYPES.PIERCER:
                                // Creates a line of destruction in its direction
                                this.handlePiercerBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.CLUSTER:
                                // Creates multiple smaller explosions
                                this.handleClusterBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.STICKY:
                                // Sticks to a block and explodes after delay
                                // Simplify by using a direct explosion
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                                
                            case this.BOMB_TYPES.SHATTERER:
                                // Creates a powerful blast
                                this.handleShattererBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.DRILLER:
                                // Handle driller bomb
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 180);
                                break;
                                
                            default:
                                // Fallback to standard explosion
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                        }
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simplified collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        if (this.initialBlockCount) {
            const revealedCount = this.initialBlockCount - this.iceBlocks.length;
            const percentage = Math.min(100, Math.floor((revealedCount / this.initialBlockCount) * 100));
            
            this.revealPercentage = percentage;
            this.events.emit('updatePercentage', percentage);
            
            console.log(`Updated reveal percentage to ${percentage}%`);
            
            // Check if we've completed the level
            if (percentage >= this.targetPercentage) {
                this.checkLevelCompletion();
            }
        }
    }

    createIceTextureEffect(veil) {
        // Add ice-like visual effects to make the veil look more like ice
        
        // Random size variations for the ice blocks (up to 10% variation)
        const sizeVariation = 0.9 + Math.random() * 0.2;
        veil.setScale(sizeVariation);
        
        // Add random inner lines/cracks simulation with slight opacity changes
        // This is simulated by making some veils slightly more transparent in certain parts
        if (Math.random() < 0.3) {
            // Around 30% of blocks will have a slightly different opacity
            veil.setAlpha(veil.alpha * (0.6 + Math.random() * 0.15));
        }
        
        // Apply a random slight tint variation to some blocks for more natural appearance
        if (Math.random() < 0.4) {
            // Apply slightly different tints to some blocks
            const tintOptions = [
                0xc8e0ff, // Very light blue 
                0xa0cfff, // Light blue
                0xb5e0ff, // Pale blue
                0xd0f0ff  // Ice blue
            ];
            const selectedTint = tintOptions[Math.floor(Math.random() * tintOptions.length)];
            veil.setFillStyle(selectedTint, veil.alpha);
        }
        
        // Create a shimmer/highlight effect for some blocks
        if (Math.random() < 0.2) { // Apply to about 20% of blocks
            // Add a highlight reflective effect that slowly moves
            const highlight = this.add.rectangle(
                veil.x,
                veil.y,
                veil.width * 0.8,
                veil.height * 0.2,
                0xffffff,
                0.25
            );
            highlight.setDepth(veil.depth + 0.1); // Just above the veil
            
            // Store a reference to the highlight in the veil
            veil.highlight = highlight;
            
            // Create shimmer animation
            this.tweens.add({
                targets: highlight,
                y: veil.y + veil.height/2,
                alpha: { from: 0.3, to: 0 },
                duration: 3000 + Math.random() * 2000,
                repeat: -1,
                yoyo: false,
                delay: Math.random() * 2000, // Random delay for each block
                onRepeat: () => {
                    highlight.y = veil.y - veil.height/2; // Reset position to top
                    highlight.alpha = 0.3;                // Reset opacity
                }
            });
        }
    }

    createSlingshot() {
        try {
            this.slingshot = this.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y, 'slingshot');
            this.slingshot.setOrigin(0.5, 0.9); // Adjust origin to bottom center
            this.slingshot.setDepth(10); // Above all game elements but below UI
            
            // Add elastic line for slingshot
            this.elasticLine = this.add.graphics();
            this.elasticLine.setDepth(11); // Above slingshot
        } catch (error) {
            console.error("Error in createSlingshot:", error);
        }
    }

    createBomb() {
        console.log("Creating bomb");
        
        // Create inactive bomb at slingshot position - simple settings
        this.bomb = this.matter.add.image(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20, 'bomb', null);
        
        this.bomb.setCircle(30); // Set physics circle radius to 30 (half of 60x60)
        this.bomb.setStatic(true);
        this.bomb.setVisible(true);
        this.bomb.setDepth(12); // Above slingshot and elastic line
        
        // Set bomb size to 60x60 (reduced from 80x80)
        this.bomb.setDisplaySize(60, 60);
        
        if (this.debugMode) {
            console.log("Bomb created:", this.bomb);
        }
    }

    setupInput() {
        try {
            // Pointer down event - works for both mouse and touch
            this.input.on('pointerdown', (pointer) => {
                try {
                    if (this.shotsRemaining <= 0 || !this.bomb || !this.bomb.visible) return;
                    
                    // Immediately log touch events for debugging
                    if (this.debugMode) {
                        console.log('Pointer down detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop, 
                            'type:', pointer.type);
                    }
                    
                    // Check if click/touch is near the bomb - use larger detection area on mobile
                    const touchRadius = this.game.device.os.desktop ? 80 : 120;
                    const distance = Phaser.Math.Distance.Between(
                        pointer.x, pointer.y, 
                        this.bomb.x, this.bomb.y
                    );
                    
                    if (distance < touchRadius) {
                        // Provide immediate visual feedback
                        this.bomb.setTint(0xffff00);
                        
                        this.isAiming = true;
                        
                        // Keep the bomb static during aiming - we'll manually position it
                        this.bomb.setStatic(true);
                        
                        // For touch devices, immediately move the bomb to the touch position
                        // This creates a more responsive feel
                        if (!this.game.device.os.desktop) {
                            // Calculate initial direction from slingshot
                            const dx = this.SLINGSHOT_X - pointer.x;
                            const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                            const distance = Math.min(
                                this.MAX_DRAG_DISTANCE,
                                Math.sqrt(dx * dx + dy * dy)
                            );
                            
                            // Calculate angle
                            const angle = Math.atan2(dy, dx);
                            
                            // Calculate bomb position
                            const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                            const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                            
                            // Update bomb position immediately
                            this.bomb.setPosition(bombX, bombY);
                            
                            // Draw elastic line immediately
                            if (this.elasticLine) {
                                this.elasticLine.clear();
                                this.elasticLine.lineStyle(3, 0xFF0000);
                                this.elasticLine.beginPath();
                                this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                                this.elasticLine.lineTo(bombX, bombY);
                                this.elasticLine.stroke();
                            }
                        }
                        
                        // Mobile touch feedback - pulse the bomb when touched
                        this.tweens.add({
                            targets: this.bomb,
                            scale: { from: 1, to: 1.2 },
                            duration: 100,
                            yoyo: true,
                            ease: 'Sine.easeInOut'
                        });
                        
                        // Add touch indicator text for mobile users
                        if (this.touchIndicator) this.touchIndicator.destroy();
                        this.touchIndicator = this.add.text(
                            this.bomb.x,
                            this.bomb.y - 60,
                            "Hold & Drag to Aim",
                            {
                                font: '16px Arial',
                                fill: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 3
                            }
                        ).setOrigin(0.5).setDepth(20);
                        
                        // Fade out the indicator after a short delay
                        this.tweens.add({
                            targets: this.touchIndicator,
                            alpha: 0,
                            delay: 1000,
                            duration: 500,
                            onComplete: () => {
                                if (this.touchIndicator) this.touchIndicator.destroy();
                            }
                        });
                        
                        if (this.debugMode && this.debugText) {
                            console.log('Aiming started');
                            this.debugText.setText(`Aiming started at ${pointer.x},${pointer.y} | distance: ${distance}`);
                        }
                    }
                } catch (error) {
                    console.error("Error in pointerdown handler:", error);
                }
            });
            
            // Pointer move event - works for both mouse and touch drag
            this.input.on('pointermove', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // On all mobile devices, make sure the pointer is down
                    // This fixes the issue where dragging doesn't work with press and hold
                    if (!pointer.isDown && !this.game.device.os.desktop) {
                        return; // Skip if touch isn't active on mobile devices
                    }
                    
                    // Calculate angle and distance from slingshot
                    const dx = this.SLINGSHOT_X - pointer.x;
                    const dy = this.SLINGSHOT_Y - 30 - pointer.y;
                    const distance = Math.min(
                        this.MAX_DRAG_DISTANCE,
                        Math.sqrt(dx * dx + dy * dy)
                    );
                    
                    // Calculate angle
                    const angle = Math.atan2(dy, dx);
                    
                    // Calculate bomb position
                    const bombX = this.SLINGSHOT_X - distance * Math.cos(angle);
                    const bombY = (this.SLINGSHOT_Y - 30) - distance * Math.sin(angle);
                    
                    // Update bomb position - keep it static while dragging
                    this.bomb.setPosition(bombX, bombY);
                    
                    // Add debug info for touch events if in debug mode
                    if (this.debugMode && this.debugText) {
                        this.debugText.setText(
                            `Aiming: pos=${bombX.toFixed(1)},${bombY.toFixed(1)} | ` +
                            `dx=${dx.toFixed(1)},dy=${dy.toFixed(1)} | ` +
                            `pointer.isDown=${pointer.isDown} | ` +
                            `mobile=${!this.game.device.os.desktop}`
                        );
                    }
                    
                    // Update touch indicator position if it exists
                    if (this.touchIndicator && this.touchIndicator.active) {
                        this.touchIndicator.setPosition(bombX, bombY - 60);
                    }
                    
                    // Draw elastic line
                    if (this.elasticLine) {
                        this.elasticLine.clear();
                        this.elasticLine.lineStyle(3, 0xFF0000);
                        this.elasticLine.beginPath();
                        this.elasticLine.moveTo(this.SLINGSHOT_X - 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.moveTo(this.SLINGSHOT_X + 10, this.SLINGSHOT_Y - 30);
                        this.elasticLine.lineTo(bombX, bombY);
                        this.elasticLine.stroke();
                    }
                    
                    // Calculate velocity based on drag distance and angle
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    // Draw trajectory prediction
                    this.drawTrajectory(bombX, bombY, forceX, forceY);
                } catch (error) {
                    console.error("Error in pointermove handler:", error);
                }
            });
            
            // Pointer up event - works for both mouse and touch release
            this.input.on('pointerup', (pointer) => {
                try {
                    if (!this.isAiming || !this.bomb) return;
                    
                    // Immediately log touch release for debugging
                    if (this.debugMode) {
                        console.log('Pointer up detected:', 
                            pointer.x, pointer.y, 
                            'isMobile:', !this.game.device.os.desktop,
                            'downTime:', pointer.downTime,
                            'upTime:', pointer.upTime,
                            'type:', pointer.type);
                    }
                    
                    // Clear any tint applied during pointerdown
                    this.bomb.clearTint();
                    
                    // Remove touch indicator if it exists
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                    
                    // Calculate force based on distance from slingshot
                    const dx = this.SLINGSHOT_X - this.bomb.x;
                    const dy = (this.SLINGSHOT_Y - 30) - this.bomb.y;
                    
                    // Check if the drag distance is significant enough to launch
                    const dragDistance = Math.sqrt(dx * dx + dy * dy);
                    if (dragDistance < 10 && !this.game.device.os.desktop) {
                        // If barely moved on mobile, don't launch - just consider it a tap
                        if (this.debugMode) {
                            console.log('Drag distance too small, not launching:', dragDistance);
                        }
                        // Reset position
                        this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                        this.isAiming = false;
                        
                        // Clear visual elements
                        if (this.elasticLine) this.elasticLine.clear();
                        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                        return;
                    }
                    
                    // Scale by shot power
                    const forceX = dx * this.SHOT_POWER * 0.01;
                    const forceY = dy * this.SHOT_POWER * 0.01;
                    
                    if (this.debugMode && this.debugText) {
                        console.log('Launching bomb with force:', forceX, forceY, 'distance:', dragDistance);
                        this.debugText.setText(`Launch: force=${forceX.toFixed(3)},${forceY.toFixed(3)} | distance=${dragDistance.toFixed(1)}`);
                    }
                    
                    // Clear elastic line
                    if (this.elasticLine) this.elasticLine.clear();
                    
                    // Clear trajectory
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    
                    try {
                        // Store current bomb position and type
                        const bombX = this.bomb.x;
                        const bombY = this.bomb.y;
                        const bombType = this.currentBombType;
                        
                        // Cancel any previous miss timer
                        if (this.bombMissTimer) {
                            this.bombMissTimer.remove();
                            this.bombMissTimer = null;
                        }
                        
                        // Remove the old static bomb
                        this.bomb.destroy();
                        
                        // Create a new dynamic bomb at the same position
                        this.createDynamicBomb(bombX, bombY, bombType, forceX, forceY);
                        
                        // Add haptic feedback for mobile devices if supported
                        if (window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100); // 100ms vibration on launch
                        }
                        
                        // Decrement bomb count
                        this.decrementBombCount(bombType);
                        
                        // Decrement shots
                        this.shotsRemaining--;
                        this.events.emit('updateShots', this.shotsRemaining);
                        
                        // Reset aiming flag
                        this.isAiming = false;
                        
                        // Set timeout to create a new bomb if shots remain
                        this.time.delayedCall(3000, () => {
                            if (this.shotsRemaining > 0) {
                                if (!this.bomb) {
                                    this.resetBomb();
                                }
                            } else {
                                // Check level completion or game over if no shots remain
                                this.checkLevelCompletion();
                            }
                        });
                    }
                    catch (error) {
                        console.error("Error launching bomb:", error);
                        if (this.debugText) this.debugText.setText(`ERROR: ${error.message}`);
                        
                        // Try to recover
                        this.resetBomb();
                    }
                } catch (error) {
                    console.error("Error in pointerup handler:", error);
                }
            });

            // Add specific handling for touch cancel events (important for mobile)
            this.input.on('pointercancel', () => {
                if (this.isAiming && this.bomb) {
                    // Reset the bomb position if touch is cancelled
                    this.isAiming = false;
                    this.bomb.setPosition(this.SLINGSHOT_X, this.SLINGSHOT_Y - 20);
                    
                    // Clear visuals
                    if (this.elasticLine) this.elasticLine.clear();
                    if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
                    if (this.touchIndicator) {
                        this.touchIndicator.destroy();
                        this.touchIndicator = null;
                    }
                }
            });
            
            // Add a pulsing hint for mobile users when a new bomb is loaded
            this.time.delayedCall(500, () => {
                this.addMobilePulseHint();
            });
            
        } catch (error) {
            console.error("Error in setupInput:", error);
        }
    }
    
    // Add a pulsing hint for mobile users to show where to touch
    addMobilePulseHint() {
        if (!this.bomb || this.hintActive) return;
        
        // Only show on mobile devices
        if (!this.game.device.os.desktop) {
            this.hintActive = true;
            
            // Create a pulsing circle around the bomb
            const hintCircle = this.add.circle(
                this.bomb.x, 
                this.bomb.y, 
                30, 
                0xffffff, 
                0.5
            ).setDepth(11);
            
            // Add a hint text
            const hintText = this.add.text(
                this.bomb.x,
                this.bomb.y - 50,
                "Tap & Drag",
                {
                    font: '18px Arial',
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3
                }
            ).setOrigin(0.5).setDepth(11);
            
            // Pulse animation
            this.tweens.add({
                targets: [hintCircle],
                scale: { from: 1, to: 1.5 },
                alpha: { from: 0.5, to: 0 },
                duration: 1000,
                repeat: 3,
                onComplete: () => {
                    hintCircle.destroy();
                    hintText.destroy();
                    this.hintActive = false;
                }
            });
            
            // Fade text after animations
            this.tweens.add({
                targets: [hintText],
                alpha: { from: 1, to: 0 },
                delay: 3000,
                duration: 1000
            });
        }
    }

    decrementBombCount(bombType) {
        // Decrement the counter for the specific bomb type
        if (this.bombsRemaining[bombType] > 0) {
            this.bombsRemaining[bombType]--;
            
            // Update the counter display
            if (this.bombCounters[bombType]) {
                this.bombCounters[bombType].setText(`x${this.bombsRemaining[bombType]}`);
            }
            
            // If we run out of this bomb type, switch to another available one
            if (this.bombsRemaining[bombType] === 0) {
                // Find another bomb type that has remaining bombs
                const availableBombType = Object.keys(this.bombsRemaining).find(type => 
                    this.bombsRemaining[type] > 0
                );
                
                if (availableBombType) {
                    this.selectBombType(availableBombType);
                }
            }
        }
    }

    setupCollisions() {
        try {
            console.log("Setting up simple collision detection for bombs and blocks...");
            
            // Set up collision between bomb and ice blocks
            this.matter.world.on('collisionstart', (event) => {
                if (!event || !event.pairs) {
                    console.error("Invalid collision event:", event);
                    return;
                }
                
                const pairs = event.pairs;
                
                // Process each collision pair
                for (let i = 0; i < pairs.length; i++) {
                    try {
                        const bodyA = pairs[i].bodyA;
                        const bodyB = pairs[i].bodyB;
                        
                        if (!bodyA || !bodyB) continue;
                        
                        // Check if one of the bodies is our bomb
                        let bombBody = null;
                        let otherBody = null;
                        
                        if (bodyA.gameObject === this.bomb) {
                            bombBody = bodyA;
                            otherBody = bodyB;
                        } else if (bodyB.gameObject === this.bomb) {
                            bombBody = bodyB;
                            otherBody = bodyA;
                        }
                        
                        // If the collision doesn't involve the bomb, skip it
                        if (!bombBody) continue;
                        
                        // Mark that the bomb has hit something
                        if (this.bomb) {
                            this.bomb.hasHitIceBlock = true;
                        }
                        
                        // Get the bomb type (use default if not set)
                        const bombType = this.bomb ? (this.bomb.bombType || this.BOMB_TYPES.BLAST) : this.BOMB_TYPES.BLAST;
                        
                        // Handle the bomb explosion based on type
                        switch(bombType) {
                            case this.BOMB_TYPES.BLAST:
                                // Standard explosion with radius damage
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                                
                            case this.BOMB_TYPES.PIERCER:
                                // Creates a line of destruction in its direction
                                this.handlePiercerBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.CLUSTER:
                                // Creates multiple smaller explosions
                                this.handleClusterBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.STICKY:
                                // Sticks to a block and explodes after delay
                                // Simplify by using a direct explosion
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                                
                            case this.BOMB_TYPES.SHATTERER:
                                // Creates a powerful blast
                                this.handleShattererBomb(this.bomb.x, this.bomb.y);
                                break;
                                
                            case this.BOMB_TYPES.DRILLER:
                                // Handle driller bomb
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 180);
                                break;
                                
                            default:
                                // Fallback to standard explosion
                                this.createExplosion(this.bomb.x, this.bomb.y);
                                this.destroyBlocksInRadius(this.bomb.x, this.bomb.y, 150);
                                break;
                        }
                        
                        // Destroy the bomb
                        if (this.bomb) {
                            this.bomb.destroy();
                            this.bomb = null;
                        }
                        
                        // Only process one valid bomb collision
                        break;
                    } catch (error) {
                        console.error("Error processing collision pair:", error);
                    }
                }
            });
            
            console.log("Simplified collision detection set up successfully");
        } catch (error) {
            console.error("Error in setupCollisions:", error);
        }
    }
    
    handleBlastBomb(x, y) {
        // Standard explosion behavior - radius effect
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 150);
    }
    
    handlePiercerBomb(x, y) {
        // Piercer bomb creates a line of destruction in its travel direction
        const velocity = this.bomb.body.velocity;
        
        // Normalize velocity to get direction
        const magnitude = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const dirX = magnitude > 0 ? velocity.x / magnitude : 0;
        const dirY = magnitude > 0 ? velocity.y / magnitude : 1;
        
        // Create a narrower but longer explosion effect
        const lineLength = 300;
        
        // Create visual effect - smaller explosion
        this.createExplosion(x, y);
        
        // Create piercing line particles
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 20, max: 50 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: 0x77aaff // Blue tint to match the bomb
        });
        
        // Emit along the trajectory line
        for (let i = 0; i < lineLength; i += 10) {
            const pointX = x + dirX * i;
            const pointY = y + dirY * i;
            emitter.explode(3, pointX, pointY);
            
            // Destroy blocks along the line
            this.destroyBlocksInRadius(pointX, pointY, 30);
            
            // Check for sticky bombs along the line
            if (i % 50 === 0) { // Check every 50 pixels to avoid too many calculations
                this.triggerStickyBomb(pointX, pointY, 60);
            }
        }
        
        // Clean up particles
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
    }
    
    handleClusterBomb(x, y) {
        // Cluster bomb creates multiple smaller explosions
        
        // Create main explosion (smaller than blast bomb)
        this.createExplosion(x, y);
        this.destroyBlocksInRadius(x, y, 100);
        
        // Check for sticky bombs in primary explosion
        this.triggerStickyBomb(x, y, 100);
        
        // Create 3-5 smaller explosions around the main one
        const numClusters = Phaser.Math.Between(3, 5);
        const clusterRadius = 150;
        
        for (let i = 0; i < numClusters; i++) {
            // Calculate random positions around the main explosion
            const angle = Math.random() * Math.PI * 2;
            const distance = 70 + Math.random() * clusterRadius;
            const clusterX = x + Math.cos(angle) * distance;
            const clusterY = y + Math.sin(angle) * distance;
            
            // Add delay based on distance from center
            const delay = distance * 2;
            
            // Create delayed cluster explosion
            this.time.delayedCall(delay, () => {
                // Create mini explosion
                this.createMiniExplosion(clusterX, clusterY);
                // Destroy blocks in smaller radius
                this.destroyBlocksInRadius(clusterX, clusterY, 70);
                // Check for sticky bombs in mini explosion
                this.triggerStickyBomb(clusterX, clusterY, 70);
            });
        }
    }
    
    createMiniExplosion(x, y) {
        // Create smaller visual explosion effect
        const explosion = this.add.circle(x, y, 40, 0xffdd44, 0.7);
        explosion.setDepth(6); // Same depth as regular explosions, above all game elements
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 1.5,
            duration: 200,
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add some particles for more effect
        const particles = this.add.particles('mini_particle');
        particles.setDepth(6); // Match explosion depth
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 150 },
            scale: { start: 1, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD'
        });
        
        // Emit particles at explosion point
        emitter.explode(20, x, y);
        
        // Destroy the particle system after emissions complete
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
        
        // Add a small camera shake
        this.cameras.main.shake(150, 0.005);
    }

    destroyBlocksInRadius(x, y, radius) {
        // Essential safety check
        if (!this.iceBlocks) {
            console.error("No iceBlocks array in destroyBlocksInRadius");
            return;
        }
        
        console.log(`Explosion at (${x}, ${y}) with radius ${radius}, checking ${this.iceBlocks.length} blocks`);
        
        // Simple approach: just loop through blocks and check distance
        let destroyedCount = 0;
        
        for (let i = 0; i < this.iceBlocks.length; i++) {
            const block = this.iceBlocks[i];
            
            // Skip invalid blocks
            if (!block || !block.isActive) continue;
            
            // Skip blocks with invalid positions
            if (typeof block.x !== 'number' || typeof block.y !== 'number') continue;
            
            // Check distance from explosion center
            const distance = Phaser.Math.Distance.Between(x, y, block.x, block.y);
            
            // If within radius, destroy it
            if (distance < radius) {
                console.log(`Block at (${block.x}, ${block.y}) is within explosion radius`);
                
                // Use BlockManager if available, otherwise use our own method
                if (this.blockManager) {
                    this.blockManager.destroyBlock(block);
                } else {
                    this.destroyIceBlock(block);
                }
                
                destroyedCount++;
            }
        }
        
        console.log(`Destroyed ${destroyedCount} blocks in explosion`);
        
        // Update the percentage for the UI
        this.updateRevealPercentage();
    }
    
    // New method to create a special effect for the Shatterer's impact on strong/eternal blocks
    createShattererImpactEffect(x, y) {
        // Create a red flash to indicate the powerful impact
        const flash = this.add.circle(x, y, 30, 0xcc3333, 0.7);
        flash.setDepth(6);
        this.tweens.add({
            targets: flash,
            alpha: 0,
            scale: 1.5,
            duration: 300,
            ease: 'Power2',
            onComplete: () => {
                flash.destroy();
            }
        });
        
        // Add crack particles
        const particles = this.add.particles('particle');
        particles.setDepth(6);
        
        const emitter = particles.createEmitter({
            speed: { min: 60, max: 120 },
            scale: { start: 0.8, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 400,
            blendMode: 'ADD',
            tint: [0xcccccc, 0xff3333, 0xffffff] // White/red/white for shattering impact
        });
        
        // Emit particles from the block center
        emitter.explode(15, x, y);
        
        // Clean up particles after use
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
        
        // Add a small camera pulse for feedback
        this.cameras.main.shake(150, 0.005);
    }

    initializeAudio() {
        console.log("Setting up audio for game level");
        
        try {
            // Check if sound system is available
            if (!this.sound || !this.sound.context) {
                console.error("Sound system not available!");
                return;
            }
            
            // Log audio context state
            console.log("Audio context state:", this.sound.context.state);
            
            // Handle autoplay restrictions in modern browsers
            if (this.sound.context.state === 'suspended') {
                console.log("Audio context suspended - waiting for user interaction");
                
                // Display a message to the user
                const clickMessage = this.add.text(
                    this.cameras.main.centerX, 
                    100, 
                    "Click anywhere to enable audio", 
                    {
                        font: '24px Arial',
                        fill: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: 4
                    }
                ).setOrigin(0.5);
                clickMessage.setDepth(this.UI_DEPTH + 10);
                
                // Make the message blink to attract attention
                this.tweens.add({
                    targets: clickMessage,
                    alpha: 0.5,
                    duration: 500,
                    yoyo: true,
                    repeat: -1
                });
                
                // Set up one-time event listener for user interaction
                const resumeAudio = () => {
                    // Attempt to resume the audio context
                    this.sound.context.resume().then(() => {
                        console.log("Audio context resumed successfully");
                        clickMessage.destroy();
                        
                        // Continue with audio initialization
                        this.createAudioManager();
                    }).catch(err => {
                        console.error("Failed to resume audio context:", err);
                    });
                };
                
                // Listen for interaction events
                this.input.once('pointerdown', resumeAudio);
                this.input.keyboard.once('keydown', resumeAudio);
            } else {
                // Audio context is already running, proceed normally
                this.createAudioManager();
            }
        } catch (error) {
            console.error("Error initializing audio:", error);
        }
    }
    
    createAudioManager() {
        // Create a simple audio manager
        this.audioManager = {
            bgMusic: null,
            victoryMusic: null,
            
            playBackgroundMusic: () => {
                try {
                    console.log("Attempting to play background music...");
                    
                    // Check if we already have a music instance
                    if (this.audioManager.bgMusic) {
                        this.audioManager.bgMusic.stop();
                    }
                    
                    // Check if the sound exists
                    if (!this.cache.audio.exists('bgMusic')) {
                        console.error("bgMusic asset not found in cache");
                        return;
                    }
                    
                    // Create and play background music
                    this.audioManager.bgMusic = this.sound.add('bgMusic', {
                        volume: 0.4,
                        loop: true
                    });
                    
                    this.audioManager.bgMusic.play();
                    console.log("Background music started successfully");
                } catch (err) {
                    console.error("Error playing background music:", err);
                }
            },
            
            playVictoryMusic: () => {
                try {
                    console.log("Attempting to play victory music...");
                    
                    // Stop background music if playing
                    if (this.audioManager.bgMusic) {
                        this.audioManager.bgMusic.stop();
                    }
                    
                    // Check if the victory music exists
                    if (!this.cache.audio.exists('victoryMusic')) {
                        console.error("victoryMusic asset not found in cache");
                        return;
                    }
                    
                    // Play victory music
                    this.audioManager.victoryMusic = this.sound.add('victoryMusic', {
                        volume: 0.6,
                        loop: false
                    });
                    
                    // Make sure it starts playing with a bit of delay
                    this.time.delayedCall(200, () => {
                        this.audioManager.victoryMusic.play();
                        console.log("Victory music started successfully");
                    });
                } catch (err) {
                    console.error("Error playing victory music:", err);
                }
            },
            
            stopAll: () => {
                if (this.audioManager.bgMusic) {
                    this.audioManager.bgMusic.stop();
                }
                if (this.audioManager.victoryMusic) {
                    this.audioManager.victoryMusic.stop();
                }
            },
            
            playGameOverSound: () => {
                try {
                    console.log("Attempting to play game over sound...");
                    
                    // Check if the game over sound exists
                    if (this.cache.audio.exists('gameOverSound')) {
                        // Play game over sound
                        this.sound.add('gameOverSound').play();
                        console.log("Game over sound started successfully");
                    } else {
                        console.warn("gameOverSound asset not found in cache, using fallback sound");
                        // Create a fallback sound effect
                        if (this.sound && this.sound.context) {
                            // Create a simple descending tone
                            const oscillator = this.sound.context.createOscillator();
                            const gainNode = this.sound.context.createGain();
                            
                            oscillator.type = 'sawtooth';
                            oscillator.frequency.setValueAtTime(440, this.sound.context.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(110, this.sound.context.currentTime + 1.5);
                            
                            gainNode.gain.setValueAtTime(0.3, this.sound.context.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, this.sound.context.currentTime + 1.5);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.sound.context.destination);
                            
                            oscillator.start();
                            oscillator.stop(this.sound.context.currentTime + 1.5);
                            
                            console.log("Fallback game over sound created");
                        }
                    }
                } catch (err) {
                    console.error("Error playing game over sound:", err);
                }
            }
        };
        
        // Add a short delay before playing music to ensure everything is loaded
        this.time.delayedCall(1000, () => {
            this.audioManager.playBackgroundMusic();
        });
    }

    // Add the missing updateBombUI method
    updateBombUI() {
        try {
            // Update the text displays for bombs remaining
            if (this.debugText) {
                this.debugText.setText(`Bomb: ${this.currentBombType} | Shots: ${this.shotsRemaining}`);
            }
            
            // Make sure bomb selection is visually updated
            this.updateBombSelection();
            
            // Update the main UI with shot count
            this.updateUI();
        } catch (error) {
            console.error("Error updating bomb UI:", error);
        }
    }

    drawTrajectory(startX, startY, velocityX, velocityY) {
        try {
            // Add debug logging
            if (this.debugMode) {
                console.log("Drawing trajectory from:", startX, startY, "with velocity:", velocityX, velocityY);
            }
            
            // Check if trajectoryGraphics exists
            if (!this.trajectoryGraphics) {
                console.error("trajectoryGraphics is not initialized");
                this.trajectoryGraphics = this.add.graphics();
                this.trajectoryGraphics.setDepth(11);
            }
            
            // Clear previous trajectory
            this.trajectoryGraphics.clear();
            
            // Number of points to predict - increased for moon trajectory
            const numPoints = 200; // Increased from 120 for much longer moon trajectory
            
            // Time step for each predicted point (in seconds)
            const timeStep = 0.1; // Reduced time step to make points closer together
            
            // Get physics properties based on current bomb type
            let density = 0.0003; // Default density for moon physics
            let frictionAir = 0.008; // Increased 4x from 0.002 for trajectory prediction
            
            // Adjust properties for special bomb types to match their actual physics
            switch(this.currentBombType) {
                case this.BOMB_TYPES.PIERCER:
                    density = 0.0005;
                    frictionAir = 0.006; // Increased 4x from 0.0015
                    break;
                case this.BOMB_TYPES.CLUSTER:
                    density = 0.0002;
                    frictionAir = 0.01; // Increased 4x from 0.0025
                    break;
                case this.BOMB_TYPES.STICKY:
                    density = 0.0003;
                    frictionAir = 0.008; // Increased 4x from 0.002
                    break;
                case this.BOMB_TYPES.SHATTERER:
                    density = 0.0004;
                    frictionAir = 0.0072; // Increased 4x from 0.0018
                    break;
                case this.BOMB_TYPES.DRILLER:
                    density = 0.0004;
                    frictionAir = 0.006; // Increased 4x from 0.0015
                    break;
            }
            
            // Gravity from the physics world - safely access with fallback value
            let gravityY = 0.008; // Quarter of moon gravity (reduced from 0.08)
            try {
                gravityY = this.matter.world.localWorld.gravity.y || 0.008;
            } catch (error) {
                console.warn("Could not access physics world gravity, using default:", error);
            }
            
            // Scale factor for velocity - safely access with fallback value
            let forceScale = 40; // Reduced from 60 for better moon trajectory prediction
            try {
                forceScale = (this.matter.world.localWorld.body?.global?.translateForceToPts || 1) * 40;
            } catch (error) {
                console.warn("Could not access physics force scale, using default:", error);
            }
            
            // Current position and velocity
            let x = startX;
            let y = startY;
            let vx = velocityX * forceScale;
            let vy = velocityY * forceScale;
            
            // Store calculated trajectory points
            this.trajectoryPoints = [];
            
            // Calculate trajectory points with extended prediction
            for (let i = 0; i < numPoints; i++) {
                // Add current point to array
                this.trajectoryPoints.push({ x, y });
                
                // Calculate next position using physics formulas
                x += vx * timeStep;
                y += vy * timeStep;
                
                // Update velocity due to gravity and air friction
                vx *= (1 - frictionAir * timeStep); // Scale air friction by timeStep
                vy *= (1 - frictionAir * timeStep); // Scale air friction by timeStep
                vy += gravityY * timeStep * 150 * density; // Apply gravity scaled by density
                
                // Skip if point is out of bounds - allow more vertical room for longer trajectories
                if (x < -500 || x > this.cameras.main.width + 500 || y < -500 || y > this.cameras.main.height + 1000) {
                    break;
                }
            }
            
            // Draw dotted line connecting trajectory points - skip some points for better performance
            if (this.trajectoryPoints.length >= 2) {
                // We'll draw fewer dots for better performance, approximately every 2-3 points
                const skipFactor = Math.ceil(this.trajectoryPoints.length / 60); // Don't draw more than ~60 dots
                
                for (let i = 0; i < this.trajectoryPoints.length; i += skipFactor) {
                    const point = this.trajectoryPoints[i];
                    const alpha = 0.95 - (i / this.trajectoryPoints.length * 0.5); // Fading alpha for distant points (more visible)
                    const radius = 7 - (i / this.trajectoryPoints.length) * 4; // Larger dots that decrease in size
                    
                    // All dots are green
                    const dotColor = 0x00ff00; // Bright green color
                    
                    // Draw a colored dot with black border - make it more visible
                    this.trajectoryGraphics.fillStyle(dotColor, alpha);
                    this.trajectoryGraphics.fillCircle(point.x, point.y, radius);
                    this.trajectoryGraphics.lineStyle(1.5, 0x000000, alpha * 0.8);
                    this.trajectoryGraphics.strokeCircle(point.x, point.y, radius);
                }
                
                if (this.debugMode) {
                    console.log(`Drew trajectory with ${this.trajectoryPoints.length} points calculated, ${Math.ceil(this.trajectoryPoints.length / skipFactor)} dots shown`);
                }
            }
        } catch (error) {
            console.error("Error drawing trajectory:", error);
        }
    }

    clearTrajectory() {
        if (this.trajectoryGraphics) {
            this.trajectoryGraphics.clear();
        }
        this.trajectoryPoints = [];
    }

    // Add new method to handle veil removal separately from level completion
    removeCompletionVeil() {
        if (this.completionVeil && !this.completionVeilRemoved) {
            console.log("Removing completion veil at " + this.revealPercentage + "% revealed");
            this.completionVeilRemoved = true;
            
            // If the completion veil is a container of blocks
            if (this.veilContainer) {
                // Fade out all individual veil blocks
                this.veilContainer.iterate(veilBlock => {
                    this.tweens.add({
                        targets: veilBlock,
                        alpha: 0,
                        duration: 1500,
                        ease: 'Power2'
                    });
                });
                
                // Remove the container after the animation completes
                this.time.delayedCall(1500, () => {
                    if (this.veilContainer && this.veilContainer.scene) {
                        this.veilContainer.destroy();
                    }
                });
            } 
            // Fallback for rectangular veil
            else if (this.completionVeil.scene) {
                // Remove the completion veil with a nice effect
                this.tweens.add({
                    targets: this.completionVeil,
                    alpha: 0,
                    duration: 1500,
                    ease: 'Power2',
                    onComplete: () => {
                        if (this.completionVeil && this.completionVeil.scene) {
                            this.completionVeil.destroy();
                        }
                    }
                });
            }
            
            // Handle frost graphics separately
            if (this.frostGraphics && this.frostGraphics.scene) {
                this.tweens.add({
                    targets: this.frostGraphics,
                    alpha: 0,
                    duration: 1500,
                    ease: 'Power2',
                    onComplete: () => {
                        if (this.frostGraphics && this.frostGraphics.scene) {
                            this.frostGraphics.destroy();
                        }
                    }
                });
            }
            
            // Add sparkle particles where the veil was
            const particles = this.add.particles('particle');
            const emitter = particles.createEmitter({
                x: 1920/2,
                y: 1080/2,
                speed: { min: 100, max: 200 },
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                lifespan: 2000,
                blendMode: 'ADD',
                tint: [0x66aaff, 0x0033aa, 0xffffff], // Blue and white ice particles
                quantity: 50,
                angle: { min: 0, max: 360 }
            });
            
            // Stop the emitter after a short duration
            this.time.delayedCall(2000, () => {
                emitter.stop();
                this.time.delayedCall(2000, () => {
                    particles.destroy();
                });
            });
        }
    }

    createCompletionVeil() {
        try {
            // Get the chibi image dimensions - no need to apply scaling since we're using original size
            const imageWidth = this.chibiImage.width;
            const imageHeight = this.chibiImage.height;
            
            // Calculate the exact boundaries
            const imageX = this.chibiImage.x - imageWidth / 2;
            const imageY = this.chibiImage.y - imageHeight / 2;
            
            console.log(`Creating completion veil for chibi at ${this.chibiImage.x}, ${this.chibiImage.y}`);
            console.log(`With bounds: ${imageX}, ${imageY}, size: ${imageWidth}x${imageHeight}`);
            
            // Create a container for the veil
            this.veilContainer = this.add.container(0, 0);
            this.veilContainer.setDepth(2); // Above chibi (1) but below ice blocks (10+)
            
            // Create a temporary canvas to check pixel data
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = imageWidth;
            tempCanvas.height = imageHeight;
            
            // Get the texture key of the chibi image
            const textureKey = this.chibiImage.texture.key;
            
            // Get the image data
            const frame = this.textures.getFrame(textureKey);
            const source = frame.source.image || frame.source.canvas;
            
            // Draw the image to our temp canvas
            tempContext.drawImage(source, 0, 0, imageWidth, imageHeight);
            
            // Create a graphics object for the frost effect
            const frostGraphics = this.add.graphics();
            frostGraphics.setDepth(2); // Same depth as veil container
            this.frostGraphics = frostGraphics;
            
            // Block size for the veil - smaller size for more precise shape
            const blockSize = 10;
            
            // Alpha threshold - lower value to include more semi-transparent pixels
            const alphaThreshold = 50; // Lower threshold to catch edge pixels
            
            // Create veil blocks that match the chibi image shape
            const rows = Math.ceil(imageHeight / blockSize);
            const cols = Math.ceil(imageWidth / blockSize);
            
            // Sample size for checking multiple pixels in the block area
            const sampleSize = 5; // Check more points in a 5x5 grid
            const sampleOffset = Math.floor(blockSize / (sampleSize + 1));
            
            // Create a 2D grid to track where we've placed veil blocks
            const veilGrid = Array(rows).fill().map(() => Array(cols).fill(false));
            
            // Keep track of non-transparent points for frost effect
            const nonTransparentPoints = [];
            
            // First pass: Find all blocks with visible pixels
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Calculate screen position
                    const blockScreenX = imageX + col * blockSize + blockSize / 2;
                    const blockScreenY = imageY + row * blockSize + blockSize / 2;
                    
                    // Sample multiple points within this block area
                    let hasVisiblePixel = false;
                    
                    for (let sx = 0; sx < sampleSize; sx++) {
                        for (let sy = 0; sy < sampleSize; sy++) {
                            // Calculate sampling position in the original image
                            const offsetX = -Math.floor(sampleSize/2) + sx;
                            const offsetY = -Math.floor(sampleSize/2) + sy;
                            
                            const sampleX = Math.floor(col * blockSize) + offsetX * sampleOffset;
                            const sampleY = Math.floor(row * blockSize) + offsetY * sampleOffset;
                            
                            // Ensure we're within bounds
                            if (sampleX >= 0 && sampleX < imageWidth && 
                                sampleY >= 0 && sampleY < imageHeight) {
                                
                                try {
                                    const pixelData = tempContext.getImageData(sampleX, sampleY, 1, 1).data;
                                    // If any sampled pixel has alpha above threshold, mark block as visible
                                    if (pixelData[3] >= alphaThreshold) {
                                        hasVisiblePixel = true;
                                        break;
                                    }
                                } catch (e) {
                                    console.error(`Error sampling pixel at ${sampleX},${sampleY}:`, e);
                                }
                            }
                        }
                        if (hasVisiblePixel) break;
                    }
                    
                    if (hasVisiblePixel) {
                        veilGrid[row][col] = true;
                        nonTransparentPoints.push({
                            x: blockScreenX,
                            y: blockScreenY
                        });
                    }
                }
            }
            
            // Second pass: Add padding around detected pixels to ensure edges are covered
            const paddingAmount = 1; // How many blocks of padding to add
            
            // Create a copy of the grid before adding padding
            const originalGrid = veilGrid.map(row => [...row]);
            
            // Add padding around each detected block
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (originalGrid[row][col]) {
                        // Add padding blocks around this block
                        for (let pr = -paddingAmount; pr <= paddingAmount; pr++) {
                            for (let pc = -paddingAmount; pc <= paddingAmount; pc++) {
                                const padRow = row + pr;
                                const padCol = col + pc;
                                
                                // Make sure we're in bounds
                                if (padRow >= 0 && padRow < rows && padCol >= 0 && padCol < cols) {
                                    veilGrid[padRow][padCol] = true;
                                    
                                    // Add these to non-transparent points if not already included
                                    const blockX = imageX + padCol * blockSize + blockSize / 2;
                                    const blockY = imageY + padRow * blockSize + blockSize / 2;
                                    
                                    // Only add if this point is not already in the array
                                    if (!nonTransparentPoints.some(p => p.x === blockX && p.y === blockY)) {
                                        nonTransparentPoints.push({
                                            x: blockX,
                                            y: blockY
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Third pass: Create veil blocks based on our grid
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (!veilGrid[row][col]) continue;
                    
                    // Calculate screen position
                    const blockScreenX = imageX + col * blockSize + blockSize / 2;
                    const blockScreenY = imageY + row * blockSize + blockSize / 2;
                    
                    // Create a veil block at this position
                    const veilBlock = this.add.rectangle(
                        blockScreenX,
                        blockScreenY,
                        blockSize,
                        blockSize,
                        0x0033aa, // Deep blue color
                        0.7
                    );
                    
                    veilBlock.setDepth(2); // Same depth as veil container
                    this.veilContainer.add(veilBlock);
                }
            }
            
            // Add frost effects at random non-transparent points
            frostGraphics.lineStyle(2, 0x66aaff, 0.3); // Light blue lines for frost effect
            
            // Number of frost patterns to create
            const numPatterns = 50;
            
            // Add crystalline patterns only in non-transparent areas
            for (let i = 0; i < numPatterns && nonTransparentPoints.length > 0; i++) {
                // Select a random point from the non-transparent pixels
                const randomIndex = Math.floor(Math.random() * nonTransparentPoints.length);
                const point = nonTransparentPoints[randomIndex];
                
                // Create a frost pattern at this point
                const size = Phaser.Math.Between(15, 40);
                
                // Draw a snowflake-like pattern
                frostGraphics.moveTo(point.x, point.y);
                frostGraphics.lineTo(point.x + size, point.y);
                frostGraphics.moveTo(point.x, point.y);
                frostGraphics.lineTo(point.x - size/2, point.y + size);
                frostGraphics.moveTo(point.x, point.y);
                frostGraphics.lineTo(point.x - size/2, point.y - size);
            }
            
            // Store reference to the veil container
            this.completionVeil = this.veilContainer;
            
            console.log('Completion veil created with shape matching chibi');
        } catch (error) {
            console.error("Error creating completion veil:", error);
            
            // Fallback to simple rectangle if there's an error
            this.completionVeil = this.add.rectangle(
                this.chibiImage.x,
                this.chibiImage.y,
                this.chibiImage.width,
                this.chibiImage.height,
                0x0033aa,
                0.7
            ).setDepth(2); // Above chibi (1) but below ice blocks (10+)
        }
    }

    handleDrillerBomb(x, y, block) {
        // Create a visual driller effect to show bomb has started drilling
        const drillerEffect = this.add.circle(x, y, 25, 0xBB5500, 0.7);
        drillerEffect.setDepth(15);
        
        // Animate the driller effect to rotate
        this.tweens.add({
            targets: drillerEffect,
            angle: 360,
            duration: 1000,
            ease: 'Linear',
            repeat: -1 // Repeat forever until removed
        });
        
        // Add particles for drilling effect
        const particles = this.add.particles('particle');
        const emitter = particles.createEmitter({
            speed: { min: 10, max: 30 },
            scale: { start: 0.3, end: 0 },
            alpha: { start: 0.7, end: 0 },
            lifespan: 800,
            blendMode: 'ADD',
            tint: 0xBB5500, // Brown/orange tint for drill
            frequency: 100, // Emit particles frequently
            quantity: 2
        });
        
        // Set particle emission point
        emitter.setPosition(x, y);
        
        // Keep a reference to the original bomb sprite and velocity
        let bombSprite = null;
        let velocityX = 0;
        let velocityY = 0;
        
        if (this.bomb) {
            // Get the bomb's velocity before making it static
            velocityX = this.bomb.body.velocity.x;
            velocityY = this.bomb.body.velocity.y;
            
            // Fix the bomb in place
            this.bomb.setStatic(true);
            
            // Store reference to the bomb sprite
            bombSprite = this.bomb;
            
            // Destroy original bomb reference - but not the visual
            this.bomb = null;
            if (this.debugMode) {
                console.log("Driller bomb placed, this.bomb reference cleared");
            }
        }
        
        // Get the direction from the bomb's velocity vector
        let directionX = 1; // Default right direction
        let directionY = 0;
        
        // Use the bomb's velocity to determine drilling direction
        const velocityMag = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
        if (velocityMag > 0.1) { // Only use velocity if it's significant
            // Normalize the velocity vector
            directionX = velocityX / velocityMag;
            directionY = velocityY / velocityMag;
            
            if (this.debugMode) {
                console.log(`Drilling direction based on velocity: ${directionX.toFixed(2)}, ${directionY.toFixed(2)}`);
            }
        } else if (block) {
            // Fallback to collision direction if velocity is too low
            // Calculate direction from block center to initial impact point
            const dx = x - block.x;
            const dy = y - block.y;
            
            // Normalize to get direction vector
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag > 0) {
                directionX = dx / mag;
                directionY = dy / mag;
                
                if (this.debugMode) {
                    console.log(`Fallback drilling direction from collision: ${directionX.toFixed(2)}, ${directionY.toFixed(2)}`);
                }
            }
        }
        
        // Blocks to drill through (up to 10)
        const maxDrillDistance = 10;
        let currentDrillDistance = 0;
        
        // Track current drill position
        let currentX = x;
        let currentY = y;
        
        // Store blocks that have been drilled through
        const drilledBlocks = [];
        
        // Keep track of the drill interval to ensure it can be cleared
        let drillInterval = null;
        
        // Drilling animation
        drillInterval = this.time.addEvent({
            delay: 200, // Drill through a block every 200ms
            callback: () => {
                // Update position based on direction
                currentX += directionX * 20; // Move 20px in drill direction
                currentY += directionY * 20; 
                
                // Move the visual effect and particles
                if (drillerEffect && drillerEffect.scene) {
                    drillerEffect.setPosition(currentX, currentY);
                }
                
                if (emitter && emitter.manager && emitter.manager.scene) {
                    emitter.setPosition(currentX, currentY);
                }
                
                // Update the bomb sprite position
                if (bombSprite && bombSprite.scene) {
                    bombSprite.setPosition(currentX, currentY);
                }
                
                // Find any blocks at the current position
                this.iceBlocks.forEach(block => {
                    if (!block || !block.isActive) return;
                    
                    // Check distance to this block
                    const distance = Phaser.Math.Distance.Between(currentX, currentY, block.x, block.y);
                    
                    // If we're close enough to a block, drill through it
                    if (distance < 20 && !drilledBlocks.includes(block)) {
                        // Add to drilled blocks
                        drilledBlocks.push(block);
                        
                        // Create a drilling effect at this block
                        this.createDrillEffect(block.x, block.y);
                        
                        // Destroy the block
                        this.destroyIceBlock(block);
                        
                        // Increment drill distance
                        currentDrillDistance++;
                        
                        // Stop if we've reached the max drill distance
                        if (currentDrillDistance >= maxDrillDistance) {
                            if (drillInterval) {
                                drillInterval.remove();
                                drillInterval = null;
                            }
                            drillingComplete();
                        }
                    }
                });
            },
            callbackScope: this,
            repeat: maxDrillDistance
        });
        
        // Function to handle the end of drilling
        const drillingComplete = () => {
            if (this.debugMode) {
                console.log(`Driller finished after drilling through ${currentDrillDistance} blocks`);
            }
            
            // Stop the drilling animation if it's still active
            if (drillInterval) {
                drillInterval.remove();
                drillInterval = null;
            }
            
            // Create a sticky effect at the final position
            const finalX = currentX;
            const finalY = currentY;
            
            // Create a unique ID for this driller bomb for debugging purposes
            const bombId = 'driller_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
            
            // Create a driller bomb object similar to sticky bomb
            const drillerBomb = {
                id: bombId,
                x: finalX,
                y: finalY,
                isActive: true,
                visualEffect: drillerEffect,
                particles: particles,
                emitter: emitter,
                bombSprite: bombSprite,
                explosionRadius: 380, // Large explosion radius when triggered
                isDriller: true, // Mark this as a driller bomb specifically
                createdAt: Date.now()  // Add timestamp for debugging
            };
            
            // Add to active sticky bombs array (reusing sticky bomb functionality)
            if (!this.activeStickyBombs) {
                this.activeStickyBombs = [];
            }
            
            // Add the new driller bomb to the array
            this.activeStickyBombs.push(drillerBomb);
            
            if (this.debugMode) {
                console.log(`Added driller bomb ${bombId} to activeStickyBombs array. Total active bombs: ${this.activeStickyBombs.length}`);
            }
            
            // Check if we need to reset the bomb after a delay to allow for the next shot
            this.time.delayedCall(1000, () => {
                if (this.shotsRemaining > 0 && !this.bomb) {
                    if (this.debugMode) {
                        console.log("Creating new bomb after placing driller bomb");
                    }
                    this.resetBomb();
                } else {
                    this.checkLevelCompletion();
                }
            });
        };
        
        // Set a failsafe timer to ensure drilling completes even if normal process fails
        this.time.delayedCall(maxDrillDistance * 300, () => {
            if (drillInterval) {
                if (this.debugMode) {
                    console.log("Failsafe: Forcing drill completion");
                }
                drillInterval.remove();
                drillInterval = null;
                drillingComplete();
            }
        });
        
        // Play a drilling sound if available
        try {
            this.sound.play('explosion', { volume: 0.3, rate: 2.0 }); // Higher pitch for drilling sound
        } catch (e) {
            console.log("Sound not available:", e);
        }
    }

    // Helper function to create a drill effect
    createDrillEffect(x, y) {
        // Create a drill dust effect
        const particles = this.add.particles('particle');
        particles.setDepth(6);
        
        // Create the emitter for debris
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 80 },
            scale: { start: 0.4, end: 0 },
            alpha: { start: 0.8, end: 0 },
            lifespan: 500,
            blendMode: 'ADD',
            tint: [0xBB5500, 0xCCCCCC], // Brown/orange and gray for drill dust
        });
        
        // Emit a burst of particles
        emitter.explode(10, x, y);
        
        // Clean up after use
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
        
        // Add a small camera shake for drilling feedback
        this.cameras.main.shake(100, 0.003);
    }

    // New helper method specifically for driller explosions
    createDrillerExplosion(x, y) {
        // Create a larger explosion effect for driller bombs with distinct visuals
        const explosion = this.add.circle(x, y, 140, 0xBB5500, 0.8);
        explosion.setDepth(6);
        
        // Animate the explosion
        this.tweens.add({
            targets: explosion,
            alpha: 0,
            scale: 3.5, // Larger scale for more impressive explosion
            duration: 600, // Longer duration
            ease: 'Power2',
            onComplete: () => {
                explosion.destroy();
            }
        });
        
        // Add drilling debris particles
        const particles = this.add.particles('particle');
        particles.setDepth(6);
        
        const emitter = particles.createEmitter({
            speed: { min: 100, max: 300 }, // Faster particles
            scale: { start: 1.8, end: 0 }, // Larger particles
            alpha: { start: 1, end: 0 },
            lifespan: 1200,
            blendMode: 'ADD',
            tint: [0xBB5500, 0xFF9900, 0xFFCC00] // Brown/orange/yellow for drill explosion
        });
        
        // Emit more particles
        emitter.explode(80, x, y);
        
        // Add a flash effect
        const flash = this.add.circle(x, y, 180, 0xffffff, 1);
        flash.setDepth(6);
        this.tweens.add({
            targets: flash,
            alpha: 0,
            duration: 300,
            onComplete: () => {
                flash.destroy();
            }
        });
        
        // Add secondary ring blast
        const ring = this.add.circle(x, y, 10, 0xFF9900, 0.7);
        ring.setStrokeStyle(4, 0xBB5500, 1);
        ring.setDepth(6);
        this.tweens.add({
            targets: ring,
            scale: 30,
            alpha: 0,
            duration: 800,
            onComplete: () => {
                ring.destroy();
            }
        });
        
        // Clean up particles after use
        this.time.delayedCall(1200, () => {
            particles.destroy();
        });
        
        // Add a stronger camera shake
        this.cameras.main.shake(500, 0.02);
        
        // Add explosion sound with lower pitch for bigger boom
        if (this.sound && this.sound.add) {
            try {
                const explosionSound = this.sound.add('explosion');
                explosionSound.play({ volume: 0.7, rate: 0.5 });
            } catch (e) {
                console.log("Sound not available:", e);
            }
        }
    }

    // New helper method to cleanly handle bomb resource cleanup
    cleanupBombResources(bomb) {
        try {
            // Clean up visual effects with error handling
            if (bomb.visualEffect) {
                if (bomb.visualEffect.scene) {
                    bomb.visualEffect.destroy();
                }
                bomb.visualEffect = null;
            }
            
            if (bomb.particles) {
                if (bomb.particles.scene) {
                    bomb.particles.destroy();
                }
                bomb.particles = null;
            }
            
            // Destroy the bomb sprite if it exists
            if (bomb.bombSprite) {
                if (bomb.bombSprite.scene) {
                    bomb.bombSprite.destroy();
                }
                bomb.bombSprite = null;
            }
            
            // Clean up any tweens that might be running on bomb elements
            if (bomb.visualEffect) this.tweens.killTweensOf(bomb.visualEffect);
            if (bomb.bombSprite) this.tweens.killTweensOf(bomb.bombSprite);
            
            // If any emitters are stored directly on the bomb
            if (bomb.emitter) {
                if (bomb.emitter.manager && bomb.emitter.manager.scene) {
                    bomb.emitter.stop();
                    bomb.emitter.remove();
                }
                bomb.emitter = null;
            }
        } catch (error) {
            console.error(`Error cleaning up bomb resources:`, error);
        }
    }

    // Add a global failsafe mechanism to detect and fix stuck game states
    setupGlobalFailsafe() {
        // Clear any existing failsafe
        if (this.globalFailsafeTimer) {
            clearInterval(this.globalFailsafeTimer);
        }
        
        // Create a periodic check that runs every 5 seconds
        this.globalFailsafeTimer = setInterval(() => {
            try {
                this.checkGameState();
            } catch (e) {
                console.error("Error in global failsafe:", e);
            }
        }, 5000);
    }
    
    // Check for stuck game states and auto-recover if needed
    checkGameState() {
        const currentTime = Date.now();
        
        // Case 1: Bomb has been active for too long without hitting anything
        if (this.bomb && this.bomb.isLaunched && 
            (currentTime - this.bombState.lastBombFired) > this.bombState.maxIdleTime) {
                
            if (this.debugMode) {
                console.warn(`FAILSAFE: Bomb active for ${Math.floor((currentTime - this.bombState.lastBombFired)/1000)}s without action`);
            }
            
            // Force cleanup and reset
            this.forceResetGameState();
            return;
        }
        
        // Case 2: No active bomb for too long but game expects one
        if (!this.bomb && !this.isLevelComplete && !this.isGameOver && 
            this.shotsRemaining > 0 && 
            (currentTime - this.bombState.lastResetTime) > 10000) {
                
            if (this.debugMode) {
                console.warn("FAILSAFE: No active bomb for 10s when one should exist");
            }
            
            // Force a bomb reset
            this.forceResetGameState();
            return;
        }
        
        // Case 3: Pending reset that never executed
        if (this.bombState.pendingReset && 
            (currentTime - this.bombState.pendingReset) > 5000) {
                
            if (this.debugMode) {
                console.warn("FAILSAFE: Pending reset never executed after 5s");
            }
            
            // Force cleanup and reset
            this.forceResetGameState();
            return;
        }
    }
    
    // Force reset the game state to recover from stuck situations
    forceResetGameState() {
        // Cancel all timers
        if (this.bombMissTimer) {
            this.bombMissTimer.remove();
            this.bombMissTimer = null;
        }
        
        if (this.pendingReset) {
            clearTimeout(this.pendingReset);
            this.pendingReset = null;
        }
        
        // Clear any stored timeouts in bombState
        if (this.bombState.autoResetTimer) {
            clearTimeout(this.bombState.autoResetTimer);
            this.bombState.autoResetTimer = null;
        }
        
        // Ensure no bomb is active
        if (this.bomb) {
            if (this.bomb.scene) {
                this.bomb.destroy();
            }
            this.bomb = null;
        }
        
        // Reset bomb state
        this.bombState.active = false;
        this.bombState.pendingReset = null;
        
        // Reset the game after a short delay
        setTimeout(() => {
            if (this.shotsRemaining > 0) {
                // Only reset the bomb if we should still have shots
                this.resetBomb();
            } else {
                // Otherwise check if the level is complete
                this.checkLevelCompletion();
            }
        }, 500);
    }

    // When scene is shutting down, clean up all resources
    shutdown() {
        // Clear the failsafe timer to prevent memory leaks
        if (this.globalFailsafeTimer) {
            clearInterval(this.globalFailsafeTimer);
            this.globalFailsafeTimer = null;
        }
        
        // Clean up any pending timeouts
        if (this.pendingReset) {
            clearTimeout(this.pendingReset);
            this.pendingReset = null;
        }
        
        if (this.bombState.autoResetTimer) {
            clearTimeout(this.bombState.autoResetTimer);
            this.bombState.autoResetTimer = null;
        }
        
        // Clean up any remaining bomb or resources
        if (this.bomb && this.bomb.scene) {
            this.bomb.destroy();
            this.bomb = null;
        }
        
        // Call original shutdown method
        super.shutdown();
    }

    // New method to handle damaging multi-hit blocks
    damageIceBlock(block) {
        if (!block || !block.isActive) return;
        
        // Reduce hits left
        block.hitsLeft--;
        
        // Create a damage effect
        this.createDamageEffect(block);
        
        // If block has no hits left, destroy it
        if (block.hitsLeft <= 0) {
            this.destroyIceBlock(block);
        } else {
            // Otherwise update the appearance to show damage
            // For Eternal Ice Blocks
            if (block.blockType === 'eternal') {
                const newAlpha = 0.75 + (block.hitsLeft * 0.05);
                if (block.blueVeil) {
                    this.tweens.add({
                        targets: block.blueVeil,
                        alpha: newAlpha,
                        duration: 200,
                        yoyo: true,
                        ease: 'Sine.easeInOut'
                    });
                }
            } 
            // For Strong Ice Blocks
            else if (block.blockType === 'strong') {
                const crackIntensity = 0.7 + ((2 - block.hitsLeft) * 0.15);
                if (block.blueVeil) {
                    this.tweens.add({
                        targets: block.blueVeil,
                        alpha: crackIntensity,
                        duration: 200,
                        yoyo: true,
                        ease: 'Sine.easeInOut'
                    });
                }
            }
        }
    }
    
    // New method to create damage effect for multi-hit blocks
    createDamageEffect(block) {
        // Create small particles to indicate damage
        const particles = this.add.particles('particle');
        particles.setDepth(6);
        
        let tint = 0xffffff; // Default
        
        // Set tint based on block type
        if (block.blockType === 'eternal') {
            tint = 0x3333cc; // Dark blue
        } else if (block.blockType === 'strong') {
            tint = 0x6666dd; // Medium blue
        }
        
        const emitter = particles.createEmitter({
            speed: { min: 30, max: 80 },
            scale: { start: 0.5, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 400,
            blendMode: 'ADD',
            tint: tint
        });
        
        // Emit particles from the center of the block
        emitter.explode(10, block.x, block.y);
        
        // Clean up particles after use
        this.time.delayedCall(500, () => {
            particles.destroy();
        });
        
        // Add a small camera shake for feedback
        this.cameras.main.shake(100, 0.005);
        
        // Play a crack sound for feedback
        if (this.sound && this.sound.add) {
            try {
                const crackSound = this.sound.add('cracksound', { volume: 0.3 });
                crackSound.play();
            } catch (e) {
                console.log("Sound not available:", e);
            }
        }
    }
    
    // New method to create effect when bouncy blocks are hit
    createBouncyHitEffect(x, y) {
        // Visual bounce effect
        const ring = this.add.circle(x, y, 20, 0x88ddff, 0.8);
        ring.setDepth(6);
        
        this.tweens.add({
            targets: ring,
            radius: 40,
            alpha: 0,
            duration: 300,
            ease: 'Sine.easeOut',
            onUpdate: (tween) => {
                // Manually update the circle size since radius isn't a standard property
                const radius = 20 + (40 - 20) * tween.progress;
                ring.setRadius(radius);
            },
            onComplete: () => {
                ring.destroy();
            }
        });
        
        // Play bounce sound
        if (this.sound && this.sound.add) {
            try {
                const bounceSound = this.sound.add('bouncesound', { volume: 0.4 });
                if (!bounceSound.isPlaying) {
                    bounceSound.play();
                }
            } catch (e) {
                console.log("Sound not available:", e);
            }
        }
    }

    // New method for dynamite block destruction effect
    createDynamiteDestroyEffect(x, y) {
        // Create special particles for dynamite
        const particles = this.add.particles('particle');
        particles.setDepth(6);
        
        const emitter = particles.createEmitter({
            speed: { min: 80, max: 200 },
            scale: { start: 1.2, end: 0 },
            alpha: { start: 1, end: 0 },
            lifespan: 600,
            blendMode: 'ADD',
            tint: [0xff0000, 0xff6600, 0xffcc00] // Red/orange/yellow
        });
        
        // Emit more particles for dynamite
        emitter.explode(40, x, y);
        
        // Add a flash effect
        const flash = this.add.circle(x, y, 80, 0xffcc00, 0.8);
        flash.setDepth(6);
        this.tweens.add({
            targets: flash,
            alpha: 0,
            scale: 2,
            duration: 200,
            onComplete: () => {
                flash.destroy();
            }
        });
        
        // Clean up particles after use
        this.time.delayedCall(700, () => {
            particles.destroy();
        });
    }

    // New method to handle bouncy block reflections
    handleBouncyBlock(block, bomb) {
        if (!bomb || !block) return;
        
        // Create the bounce effect
        this.createBouncyHitEffect(block.x, block.y);
        
        // Get incoming velocity
        const vx = bomb.body.velocity.x;
        const vy = bomb.body.velocity.y;
        
        // Calculate normal vector from block to bomb (for reflection)
        const nx = bomb.x - block.x;
        const ny = bomb.y - block.y;
        
        // Normalize the normal vector
        const length = Math.sqrt(nx * nx + ny * ny);
        const nnx = nx / length;
        const nny = ny / length;
        
        // Calculate dot product of velocity and normal
        const dot = vx * nnx + vy * nny;
        
        // Calculate reflection vector (v - 2 * dot * n)
        const reflectVx = vx - 2 * dot * nnx;
        const reflectVy = vy - 2 * dot * nny;
        
        // Add a bit of randomness to the reflection
        const randomRange = 0.2; // 20% randomness
        const randomFactor = 1 + (Math.random() * randomRange - randomRange/2);
        
        // Apply reflection velocity with a boost
        const boostFactor = 1.2; // 20% speed boost on reflection
        bomb.setVelocity(
            reflectVx * boostFactor * randomFactor, 
            reflectVy * boostFactor * randomFactor
        );
        
        // Add a rotation effect
        bomb.setAngularVelocity((Math.random() - 0.5) * 0.2);
        
        // Add a trail effect to the bounced bomb
        this.createBounceTrail(bomb);
    }
    
    // New method to add a visual trail to bounced bombs
    createBounceTrail(bomb) {
        if (!bomb || !bomb.scene) return;
        
        // Create trail particles
        const particles = this.add.particles('particle');
        particles.setDepth(5);
        
        const emitter = particles.createEmitter({
            lifespan: 300,
            speed: { min: 5, max: 20 },
            scale: { start: 0.4, end: 0 },
            alpha: { start: 0.6, end: 0 },
            blendMode: 'ADD',
            tint: 0x88ddff, // Light blue for bounce trail
            frequency: 20, // Emit a particle every 20ms
            emitZone: {
                type: 'edge',
                source: new Phaser.Geom.Circle(0, 0, 5),
                quantity: 1
            }
        });
        
        // Track the bomb to emit particles
        emitter.startFollow(bomb);
        
        // Clean up particles if bomb is destroyed
        this.time.delayedCall(1200, () => {
            if (particles && particles.scene) {
                particles.destroy();
            }
        });
        
        // Remove the trail after a short time (if bomb hasn't exploded yet)
        this.time.delayedCall(800, () => {
            if (emitter && emitter.manager && emitter.manager.scene) {
                emitter.stopFollow();
                emitter.stop();
            }
        });
    }

    // New method to create bouncy blocks around the level boundaries
    createBoundaryBouncyBlocks() {
        console.log("Creating bouncy block boundaries");
        const blockSize = 30; // Larger size for boundary blocks
        const spacing = blockSize; // Place blocks with no gaps
        
        // Add boundary blocks to iceBlocks array if not already created
        if (!this.boundaryBlocks) {
            this.boundaryBlocks = [];
        }
        
        // Define the physics properties for bouncy blocks
        const bouncyPhysicsProps = {
            isStatic: true,
            friction: 0.01,
            restitution: 1.0 // High restitution for maximum bounce
        };
        
        // Top boundary (full width)
        for (let x = 0; x < this.cameras.main.width; x += spacing) {
            this.createBoundaryBlock(x + blockSize/2, blockSize/2, blockSize, bouncyPhysicsProps);
        }
        
        // Bottom boundary (full width)
        for (let x = 0; x < this.cameras.main.width; x += spacing) {
            this.createBoundaryBlock(x + blockSize/2, this.cameras.main.height - blockSize/2, blockSize, bouncyPhysicsProps);
        }
        
        // Right boundary (full height, excluding corners which were added with top/bottom)
        for (let y = blockSize; y < this.cameras.main.height - blockSize; y += spacing) {
            this.createBoundaryBlock(this.cameras.main.width - blockSize/2, y + blockSize/2, blockSize, bouncyPhysicsProps);
        }
        
        console.log(`Created ${this.boundaryBlocks.length} bouncy blocks for level boundaries`);
    }
    
    // Helper method to create a single boundary block
    createBoundaryBlock(x, y, blockSize, physicsProps) {
        // Create the block
        const block = this.matter.add.image(x, y, 'iceBlock', null, physicsProps);
        
        // Scale the block to the desired size
        block.setScale(blockSize / 40); // Original ice block is 40x40
        
        // Set block properties
        block.setDepth(4); // Same depth as other blocks
        block.setAlpha(0.5);
        block.isActive = true;
        block.blockType = 'bouncy';
        block.hitsLeft = 1;
        
        // Create a green veil for the bouncy block
        const blockVeil = this.add.rectangle(
            x, 
            y, 
            blockSize, 
            blockSize, 
            0x00cc44, // Green color for bouncy blocks
            0.9
        );
        
        // Add a metallic look with highlights
        blockVeil.setStrokeStyle(2, 0xffffff, 0.5);
        blockVeil.setDepth(3);
        
        // Store reference to the veil in the block
        block.blueVeil = blockVeil;
        
        // Add some shine effect to make it look metallic
        this.createIceTextureEffect(blockVeil);
        
        // Add some pulsating effect to indicate it's a bouncy block
        this.tweens.add({
            targets: blockVeil,
            alpha: { from: 0.9, to: 0.6 },
            yoyo: true,
            repeat: -1,
            duration: 1500,
            ease: 'Sine.easeInOut'
        });
        
        // Add the block to arrays for tracking
        this.iceBlocks.push(block);
        this.blueVeils.push(blockVeil);
        this.boundaryBlocks.push(block);
        
        return block;
    }
}